#!/bin/bash
# A simple script to set up the environment and install dependencies.

# Parse command line arguments
SKIP_MKCERT=false
UPGRADE_PYTHON=false
for arg in "$@"; do
    case $arg in
        --skip-mkcert)
            SKIP_MKCERT=true
            shift
            ;;
        --upgrade-python)
            UPGRADE_PYTHON=true
            shift
            ;;
        --help|-h)
            echo "Usage: $0 [OPTIONS]"
            echo "Options:"
            echo "  --skip-mkcert      Skip mkcert installation (for manual SSL cert management)"
            echo "  --upgrade-python   Install/upgrade to Python 3.8+ if needed"
            echo "  --help, -h         Show this help message"
            echo ""
            echo "Python Version Requirements:"
            echo "  - Poetry 2.x requires Python 3.8 or higher"
            echo "  - If you have Python 3.6/3.7, use --upgrade-python to install a newer version"
            exit 0
            ;;
        *)
            echo "Unknown option: $arg"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Function to detect system information
detect_system() {
    # Detect OS
    OS="$(uname -s)"
    
    # Detect Linux distribution
    if [ "$OS" = "Linux" ] && [ -f /etc/os-release ]; then
        . /etc/os-release
        DISTRO="$ID"
        DISTRO_VERSION="$VERSION_ID"
        DISTRO_NAME="$PRETTY_NAME"
    else
        DISTRO="unknown"
        DISTRO_VERSION="unknown"
        DISTRO_NAME="$(uname -s) $(uname -r)"
    fi
    
    # Detect package manager
    if command -v apt-get &> /dev/null; then
        PKG_MANAGER="apt-get"
    elif command -v dnf &> /dev/null; then
        PKG_MANAGER="dnf"
    elif command -v yum &> /dev/null; then
        PKG_MANAGER="yum"
    elif command -v zypper &> /dev/null; then
        PKG_MANAGER="zypper"
    elif command -v pacman &> /dev/null; then
        PKG_MANAGER="pacman"
    elif command -v brew &> /dev/null; then
        PKG_MANAGER="brew"
    else
        PKG_MANAGER="unknown"
    fi
    
    echo "🖥️  System: $DISTRO_NAME"
    echo "📦 Package manager: $PKG_MANAGER"
}

# --- Dependency Checks ---

echo "--- Checking Prerequisites ---"
detect_system
echo ""

# Check for Python 3 and version
check_python_version() {
    if ! command -v python3 &> /dev/null; then
        echo "❌ [ERROR] 'python3' could not be found."
        echo "Please install Python 3 from https://www.python.org/downloads/ and try again."
        return 1
    fi

    # Debug: show which python3 we're using
    python3_path=$(which python3 2>/dev/null || echo "unknown")
    echo "🔍 Using python3 from: $python3_path"
    
    # Get Python version
    python_version=$(python3 -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')" 2>/dev/null || echo "unknown")
    echo "🐍 Python version: $python_version"
    
    # Check if version meets Poetry 2.x requirements (Python 3.8+)
    if python3 -c "import sys; exit(0 if sys.version_info >= (3, 8) else 1)" 2>/dev/null; then
        echo "✅ Python version is compatible with Poetry 2.x"
        return 0
    else
        echo "⚠️  Python $python_version detected. Poetry 2.x requires Python 3.8+"
        return 2
    fi
}

# Function to set up Python alternatives (cross-platform)
setup_python_alternatives() {
    local python_path="$1"
    local pip_path="$2"
    
    echo "🔧 Setting up Python alternatives..."
    
    # Method 1: Try update-alternatives (most common)
    if command -v update-alternatives &> /dev/null; then
        echo "Using update-alternatives..."
        if sudo update-alternatives --install /usr/bin/python3 python3 "$python_path" 100 2>/dev/null && \
           sudo update-alternatives --install /usr/bin/pip3 pip3 "$pip_path" 100 2>/dev/null; then
            sudo update-alternatives --set python3 "$python_path" 2>/dev/null || true
            sudo update-alternatives --set pip3 "$pip_path" 2>/dev/null || true
            return 0
        fi
    fi
    
    # Method 2: Try alternatives (older RHEL/CentOS)
    if command -v alternatives &> /dev/null; then
        echo "Using alternatives (legacy)..."
        if sudo alternatives --install /usr/bin/python3 python3 "$python_path" 100 2>/dev/null && \
           sudo alternatives --install /usr/bin/pip3 pip3 "$pip_path" 100 2>/dev/null; then
            sudo alternatives --set python3 "$python_path" 2>/dev/null || true
            sudo alternatives --set pip3 "$pip_path" 2>/dev/null || true
            return 0
        fi
    fi
    
    # Method 3: Direct symlinks (fallback for all systems)
    echo "Using direct symlinks as fallback..."
    if sudo ln -sf "$python_path" /usr/bin/python3 2>/dev/null && \
       sudo ln -sf "$pip_path" /usr/bin/pip3 2>/dev/null; then
        return 0
    fi
    
    # Method 4: Try /usr/local/bin symlinks (for systems where /usr/bin is protected)
    echo "Trying /usr/local/bin symlinks..."
    sudo mkdir -p /usr/local/bin
    if sudo ln -sf "$python_path" /usr/local/bin/python3 2>/dev/null && \
       sudo ln -sf "$pip_path" /usr/local/bin/pip3 2>/dev/null; then
        # Ensure /usr/local/bin is in PATH
        if ! echo "$PATH" | grep -q "/usr/local/bin"; then
            export PATH="/usr/local/bin:$PATH"
            echo 'export PATH="/usr/local/bin:$PATH"' >> ~/.bashrc
        fi
        return 0
    fi
    
    echo "⚠️  Warning: Could not set up Python alternatives automatically"
    echo "Manual setup may be required."
    return 1
}

# Function to install Python 3.8+ on different distributions
install_newer_python() {
    echo "🔄 Installing Python 3.8+ for your system..."
    OS="$(uname -s)"
    
    if [ "$OS" = "Darwin" ]; then
        echo "Installing Python via Homebrew..."
        if command -v brew &> /dev/null; then
            brew install python@3.11
            echo "✅ Python 3.11 installed via Homebrew"
            echo "You may need to update your PATH or use 'python3.11' directly"
        else
            echo "❌ Homebrew not found. Please install it first or install Python manually."
            return 1
        fi
        return 0
    fi
    
    # Detect Linux distribution
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        DISTRO=$ID
    else
        DISTRO="unknown"
    fi
    
    case "$DISTRO" in
                 ubuntu|debian)
             echo "Installing Python 3.11 via deadsnakes PPA..."
             sudo apt-get update
             sudo apt-get install -y software-properties-common
             sudo add-apt-repository ppa:deadsnakes/ppa -y
             sudo apt-get update
             sudo apt-get install -y python3.11 python3.11-venv python3.11-pip python3.11-dev
             
             # Verify installation
             if ! python3.11 --version &> /dev/null; then
                 echo "❌ Failed to install Python 3.11"
                 return 1
             fi
             
             echo "✅ Python 3.11 installed successfully"
             echo "Setting python3.11 as default python3..."
             setup_python_alternatives "/usr/bin/python3.11" "/usr/bin/pip3.11"
             ;;
            
        fedora)
            echo "Installing Python 3.11 via dnf..."
            sudo dnf install -y python3.11 python3.11-pip python3.11-devel
            
            if ! python3.11 --version &> /dev/null; then
                echo "❌ Failed to install Python 3.11"
                return 1
            fi
            
            echo "✅ Python 3.11 installed successfully"
            echo "Setting python3.11 as default python3..."
            setup_python_alternatives "/usr/bin/python3.11" "/usr/bin/pip3.11"
            ;;
            
                 centos|rhel|rocky|almalinux)
             echo "Installing Python 3.11 on RHEL/CentOS-based system..."
             
             # Try different methods based on version
             if command -v dnf &> /dev/null; then
                 # Try EPEL and PowerTools first
                 sudo dnf install -y epel-release
                 sudo dnf config-manager --set-enabled powertools 2>/dev/null || sudo dnf config-manager --set-enabled PowerTools 2>/dev/null || true
                 
                 if sudo dnf install -y python3.11 python3.11-pip python3.11-devel 2>/dev/null; then
                     echo "✅ Python 3.11 installed via dnf"
                     setup_python_alternatives "/usr/bin/python3.11" "/usr/bin/pip3.11"
                 else
                     echo "Trying alternative installation method..."
                     install_python_from_source "3.11.7"
                 fi
             elif command -v yum &> /dev/null; then
                 # For older CentOS versions, first try to install Python 3.11 from EPEL
                 sudo yum install -y epel-release
                                   if sudo yum install -y python3.11 python3.11-pip python3.11-devel 2>/dev/null; then
                      echo "✅ Python 3.11 installed via yum"
                      setup_python_alternatives "/usr/bin/python3.11" "/usr/bin/pip3.11"
                 else
                     # Fallback to Software Collections or source
                     if yum list available | grep -q rh-python38; then
                         sudo yum install -y centos-release-scl
                         sudo yum install -y rh-python38 rh-python38-python-pip rh-python38-python-devel
                         echo "✅ Python 3.8 installed via Software Collections"
                         
                         # Create wrapper scripts that enable SCL
                         sudo tee /usr/local/bin/python3 > /dev/null << 'EOF'
#!/bin/bash
source /opt/rh/rh-python38/enable
exec python3 "$@"
EOF
                         sudo tee /usr/local/bin/pip3 > /dev/null << 'EOF'
#!/bin/bash
source /opt/rh/rh-python38/enable
exec pip3 "$@"
EOF
                         sudo chmod +x /usr/local/bin/python3 /usr/local/bin/pip3
                         export PATH="/usr/local/bin:$PATH"
                     else
                         echo "Installing Python from source..."
                         install_python_from_source "3.11.7"
                     fi
                 fi
             fi
             ;;
            
        opensuse*|sles)
            echo "Installing Python 3.11 via zypper..."
            sudo zypper install -y python311 python311-pip python311-devel
            
            if ! python3.11 --version &> /dev/null; then
                echo "❌ Failed to install Python 3.11"
                return 1
            fi
            
            echo "✅ Python 3.11 installed successfully"
            setup_python_alternatives "/usr/bin/python3.11" "/usr/bin/pip3.11"
            ;;
            
        arch|manjaro)
            echo "Installing Python via pacman..."
            sudo pacman -S --noconfirm python python-pip
            echo "✅ Python installed successfully"
            # Arch usually has the latest Python as default, but let's verify
            if ! python3 -c "import sys; exit(0 if sys.version_info >= (3, 8) else 1)" 2>/dev/null; then
                echo "⚠️  Arch Python version might be too old, trying python3.11..."
                sudo pacman -S --noconfirm python311 python311-pip 2>/dev/null || true
                setup_python_alternatives "/usr/bin/python3.11" "/usr/bin/pip3.11"
            fi
            ;;
            
        *)
            echo "Unknown distribution: $DISTRO"
            echo "Attempting to install Python from source..."
            install_python_from_source "3.11.7"
            ;;
    esac
    
    # Verify that python3 now points to the new version
    echo "🔍 Verifying Python 3 installation..."
    hash -r  # Clear command hash table
    export PATH="/usr/local/bin:$PATH"  # Ensure /usr/local/bin is prioritized
    
    sleep 1  # Give the system a moment to update
    
    new_python_version=$(python3 -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')" 2>/dev/null || echo "unknown")
    if python3 -c "import sys; exit(0 if sys.version_info >= (3, 8) else 1)" 2>/dev/null; then
        echo "✅ Verification successful: python3 now points to version $new_python_version"
        return 0
    else
        echo "⚠️  Warning: python3 still points to version $new_python_version (< 3.8)"
        echo "This may require a shell restart or manual PATH update."
        return 1
    fi
}

# Function to install Python from source (fallback method)
install_python_from_source() {
    local python_version=${1:-"3.11.7"}
    echo "📦 Installing Python $python_version from source..."
    
    # Install build dependencies
    if command -v apt-get &> /dev/null; then
        sudo apt-get update
        sudo apt-get install -y build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libsqlite3-dev wget libbz2-dev
    elif command -v dnf &> /dev/null; then
        sudo dnf groupinstall -y "Development Tools"
        sudo dnf install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel expat-devel
    elif command -v yum &> /dev/null; then
        sudo yum groupinstall -y "Development Tools"
        sudo yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel expat-devel
    fi
    
    # Download and compile Python
    cd /tmp
    wget https://www.python.org/ftp/python/$python_version/Python-$python_version.tgz
    tar xzf Python-$python_version.tgz
    cd Python-$python_version
    
    ./configure --enable-optimizations --prefix=/usr/local
    make -j $(nproc)
    sudo make altinstall
    
    # Set up alternatives for source-compiled Python
    setup_python_alternatives "/usr/local/bin/python3.11" "/usr/local/bin/pip3.11"
    
    # Update PATH
    echo 'export PATH="/usr/local/bin:$PATH"' >> ~/.bashrc
    export PATH="/usr/local/bin:$PATH"
    
    # Clean up
    cd /
    rm -rf /tmp/Python-$python_version*
    
    echo "✅ Python $python_version installed from source in /usr/local"
    echo "You may need to restart your shell or run: source ~/.bashrc"
}

# Main Python check
python_check_result=0
check_python_version || python_check_result=$?

if [ $python_check_result -eq 1 ]; then
    # Python not found at all
    exit 1
elif [ $python_check_result -eq 2 ]; then
    # Python found but version too old
    if [ "$UPGRADE_PYTHON" = true ]; then
        echo "🚀 Upgrading Python as requested..."
        if install_newer_python; then
            echo "✅ Python upgrade completed"
            echo "🔄 Re-checking Python version..."
            
            # Refresh command hash and PATH
            hash -r
            export PATH="/usr/local/bin:$PATH"
            
            # Re-run the Python version check
            if check_python_version; then
                echo "✅ Python upgrade verification successful"
            else
                echo "❌ Python upgrade verification failed"
                echo ""
                echo "The newer Python was installed but python3 still points to the old version."
                echo "This can happen due to shell caching or PATH issues."
                echo ""
                echo "📋 Manual steps to fix:"
                echo "1. Open a new terminal/shell session"
                echo "2. Run: source ~/.bashrc"
                echo "3. Check: python3 --version"
                echo "4. Re-run: ./setup"
                echo ""
                exit 1
            fi
        else
            echo "❌ Failed to upgrade Python"
            exit 1
        fi
    else
        echo ""
        echo "📋 Options to resolve this:"
        echo "1. Re-run with --upgrade-python to automatically install Python 3.8+"
        echo "2. Install Python 3.8+ manually:"
        echo "   • Ubuntu/Debian: sudo apt install python3.11"
        echo "   • CentOS/RHEL: sudo dnf install python3.11"
        echo "   • Or compile from source"
        echo "3. Use pyenv to manage Python versions"
        echo ""
        exit 1
    fi
fi

# Check for Docker
if ! command -v docker &> /dev/null; then
    echo "❌ [ERROR] 'docker' could not be found."
    echo "Please install Docker Desktop from https://www.docker.com/products/docker-desktop and try again."
    exit 1
fi
echo "✅ Docker found."

# Check for Git
if ! command -v git &> /dev/null; then
    echo "❌ [ERROR] 'git' could not be found."
    echo "Attempting to install git..."
    if [[ "$(uname -s)" == "Darwin" ]]; then
        # On macOS, git is often installed via Xcode Command Line Tools, which brew can trigger.
        brew install git
    elif command -v apt-get &> /dev/null; then
        sudo apt-get update && sudo apt-get install -y git
    elif command -v dnf &> /dev/null; then
        sudo dnf install -y git
    elif command -v yum &> /dev/null; then
        sudo yum install -y git
    elif command -v zypper &> /dev/null; then
        sudo zypper install -y git
    elif command -v pacman &> /dev/null; then
        sudo pacman -S --noconfirm git
    else
        echo "Could not install git automatically. Please install it manually."
        echo "Common commands:"
        echo "  • Ubuntu/Debian: sudo apt install git"
        echo "  • Fedora: sudo dnf install git"
        echo "  • CentOS/RHEL: sudo yum install git"
        echo "  • openSUSE: sudo zypper install git"
        echo "  • Arch: sudo pacman -S git"
        exit 1
    fi
fi
echo "✅ Git found."

# Check for curl
if ! command -v curl &> /dev/null; then
    echo "❌ [ERROR] 'curl' could not be found."
    echo "Attempting to install curl..."
    if [[ "$(uname -s)" == "Darwin" ]]; then
        # On macOS, curl is usually pre-installed, but just in case
        brew install curl
    elif command -v apt-get &> /dev/null; then
        sudo apt-get update && sudo apt-get install -y curl
    elif command -v dnf &> /dev/null; then
        sudo dnf install -y curl
    elif command -v yum &> /dev/null; then
        sudo yum install -y curl
    elif command -v zypper &> /dev/null; then
        sudo zypper install -y curl
    elif command -v pacman &> /dev/null; then
        sudo pacman -S --noconfirm curl
    else
        echo "Could not install curl automatically. Please install it manually."
        echo "Common commands:"
        echo "  • Ubuntu/Debian: sudo apt install curl"
        echo "  • Fedora: sudo dnf install curl" 
        echo "  • CentOS/RHEL: sudo yum install curl"
        echo "  • openSUSE: sudo zypper install curl"
        echo "  • Arch: sudo pacman -S curl"
        exit 1
    fi
fi
echo "✅ curl found."

# Check for Homebrew on macOS (for mkcert)
if [[ "$(uname -s)" == "Darwin" ]] && ! command -v brew &> /dev/null && [[ "$SKIP_MKCERT" == false ]]; then
    echo "❌ [ERROR] 'brew' (Homebrew) is not installed."
    echo "Please install it from https://brew.sh/ and try again."
    echo "Or use --skip-mkcert to skip certificate tools installation."
    exit 1
fi
echo "--------------------------"
echo ""

# Function to install mkcert with multiple methods
install_mkcert() {
    echo "Checking for mkcert..."
    OS="$(uname -s)"

    # If mkcert is already installed, just ensure CA is trusted
    if command -v mkcert &> /dev/null; then
        echo "✅ mkcert is already installed."
        echo "Ensuring local CA is trusted..."
        mkcert -install
        return 0
    fi

    case "${OS}" in
        Linux*)
            echo "Detected Linux OS."
            
            # Detect Linux distribution
            if [ -f /etc/os-release ]; then
                . /etc/os-release
                DISTRO=$ID
            else
                DISTRO="unknown"
            fi
            
            echo "Distribution: $DISTRO"
            
            # Try different installation methods based on distribution
            case "$DISTRO" in
                ubuntu|debian)
                    echo "Installing mkcert using apt-get..."
                    if sudo apt-get update && sudo apt-get install -y libnss3-tools; then
                        install_mkcert_binary
                    else
                        echo "Failed to install dependencies with apt-get"
                        return 1
                    fi
                    ;;
                fedora)
                    echo "Installing mkcert using dnf..."
                    if command -v dnf &> /dev/null && sudo dnf install -y nss-tools; then
                        if ! sudo dnf install -y mkcert 2>/dev/null; then
                            echo "mkcert not available in dnf, trying binary installation..."
                            install_mkcert_binary
                        fi
                    else
                        echo "Failed to install dependencies with dnf"
                        return 1
                    fi
                    ;;
                centos|rhel|rocky|almalinux)
                    echo "Installing mkcert on RHEL/CentOS-based system..."
                    
                    # Install NSS tools first
                    if command -v dnf &> /dev/null; then
                        sudo dnf install -y nss-tools
                    elif command -v yum &> /dev/null; then
                        sudo yum install -y nss-tools
                    fi
                    
                    # Try EPEL repository first
                    if ! install_mkcert_epel; then
                        echo "EPEL installation failed, trying binary installation..."
                        install_mkcert_binary
                    fi
                    ;;
                opensuse*|sles)
                    echo "Installing mkcert on openSUSE/SLES..."
                    if sudo zypper install -y mozilla-nss-tools; then
                        install_mkcert_binary
                    else
                        echo "Failed to install dependencies with zypper"
                        return 1
                    fi
                    ;;
                arch|manjaro)
                    echo "Installing mkcert using pacman..."
                    if sudo pacman -S --noconfirm nss; then
                        if ! sudo pacman -S --noconfirm mkcert 2>/dev/null; then
                            echo "mkcert not available in pacman, trying AUR or binary..."
                            install_mkcert_binary
                        fi
                    else
                        echo "Failed to install dependencies with pacman"
                        return 1
                    fi
                    ;;
                *)
                    echo "Unknown or unsupported Linux distribution: $DISTRO"
                    echo "Attempting generic binary installation..."
                    install_mkcert_binary
                    ;;
            esac
            ;;
        Darwin*)
            echo "Detected macOS."
            echo "Installing mkcert with Homebrew..."
            if ! brew install mkcert; then
                echo "Failed to install mkcert with Homebrew"
                return 1
            fi
            ;;
        *)
            echo "Unsupported OS: ${OS}"
            echo "Attempting generic binary installation..."
            install_mkcert_binary
            ;;
    esac
    
    # Verify installation and trust CA
    if command -v mkcert &> /dev/null; then
        echo "✅ mkcert installed successfully. Ensuring local CA is trusted..."
        mkcert -install
        return 0
    else
        echo "❌ [ERROR] mkcert installation failed."
        return 1
    fi
}

# Function to install mkcert from EPEL repository
install_mkcert_epel() {
    echo "Attempting to install mkcert from EPEL repository..."
    
    # Enable EPEL repository
    if command -v dnf &> /dev/null; then
        if ! sudo dnf install -y epel-release 2>/dev/null; then
            echo "Failed to install EPEL repository"
            return 1
        fi
        if sudo dnf install -y mkcert 2>/dev/null; then
            echo "✅ mkcert installed from EPEL"
            return 0
        fi
    elif command -v yum &> /dev/null; then
        if ! sudo yum install -y epel-release 2>/dev/null; then
            echo "Failed to install EPEL repository"
            return 1
        fi
        if sudo yum install -y mkcert 2>/dev/null; then
            echo "✅ mkcert installed from EPEL"
            return 0
        fi
    fi
    
    return 1
}

# Function to install mkcert binary directly from GitHub releases
install_mkcert_binary() {
    echo "Installing mkcert from GitHub releases..."
    
    # Detect architecture
    ARCH="$(uname -m)"
    case "$ARCH" in
        x86_64) ARCH="amd64" ;;
        aarch64|arm64) ARCH="arm64" ;;
        armv7l) ARCH="arm" ;;
        i386|i686) ARCH="386" ;;
        *) 
            echo "Unsupported architecture: $ARCH"
            return 1
            ;;
    esac
    
    # Detect OS for binary naming
    OS_LOWER="$(uname -s | tr '[:upper:]' '[:lower:]')"
    
    # Get latest release version
    echo "Fetching latest mkcert release information..."
    LATEST_VERSION=$(curl -s https://api.github.com/repos/FiloSottile/mkcert/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    
    if [ -z "$LATEST_VERSION" ]; then
        echo "Failed to get latest version information"
        return 1
    fi
    
    echo "Latest version: $LATEST_VERSION"
    
    # Construct download URL
    BINARY_NAME="mkcert-${LATEST_VERSION}-${OS_LOWER}-${ARCH}"
    DOWNLOAD_URL="https://github.com/FiloSottile/mkcert/releases/download/${LATEST_VERSION}/${BINARY_NAME}"
    
    echo "Downloading: $DOWNLOAD_URL"
    
    # Download and install
    if curl -L -o /tmp/mkcert "$DOWNLOAD_URL"; then
        sudo chmod +x /tmp/mkcert
        sudo mv /tmp/mkcert /usr/local/bin/mkcert
        echo "✅ mkcert binary installed to /usr/local/bin/mkcert"
        return 0
    else
        echo "Failed to download mkcert binary"
        return 1
    fi
}

# --- Main script ---

# 1. Install mkcert (unless skipped)
if [[ "$SKIP_MKCERT" == true ]]; then
    echo "⏭️  Skipping mkcert installation as requested."
    echo "   Note: You'll need to provide your own SSL certificates or use reverse-proxy mode."
else
    if ! install_mkcert; then
        echo ""
        echo "❌ [ERROR] Failed to install mkcert automatically."
        echo ""
        echo "📋 Manual installation options:"
        echo "1. Download from: https://github.com/FiloSottile/mkcert/releases"
        echo "2. Use package manager specific to your distribution"
        echo "3. Build from source: https://github.com/FiloSottile/mkcert"
        echo "4. Re-run this script with --skip-mkcert and provide your own certificates"
        echo ""
        exit 1
    fi
fi

# 2. Install Poetry and dependencies
echo -e "\n--- Setting up Python Environment with Poetry ---"

# Function to install Poetry with error handling
install_poetry() {
    local attempt=1
    local max_attempts=3
    
    while [ $attempt -le $max_attempts ]; do
        echo "📦 Installing Poetry (attempt $attempt/$max_attempts)..."
        
        if curl -sSL https://install.python-poetry.org | python3 -; then
            # Add poetry to the path for the current session
            export PATH="$HOME/.local/bin:$PATH"
            
            # Verify installation
            if command -v poetry &> /dev/null; then
                echo "✅ Poetry installed successfully"
                return 0
            else
                echo "⚠️  Poetry installed but not found in PATH"
                echo "Checking common installation locations..."
                
                # Try common Poetry installation paths
                for poetry_path in "$HOME/.local/bin/poetry" "$HOME/.poetry/bin/poetry" "/usr/local/bin/poetry"; do
                    if [ -x "$poetry_path" ]; then
                        echo "Found Poetry at: $poetry_path"
                        export PATH="$(dirname "$poetry_path"):$PATH"
                        return 0
                    fi
                done
            fi
        else
            echo "❌ Poetry installation failed on attempt $attempt"
        fi
        
        if [ $attempt -lt $max_attempts ]; then
            echo "🔄 Retrying in 2 seconds..."
            sleep 2
        fi
        
        attempt=$((attempt + 1))
    done
    
    return 1
}

# Check if Poetry is already installed
if command -v poetry &> /dev/null; then
    echo "✅ Poetry is already installed"
    poetry_version=$(poetry --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    if [ -n "$poetry_version" ]; then
        echo "🐍 Poetry version: $poetry_version"
    fi
else
    echo "Poetry not found. Installing Poetry..."
    
    if ! install_poetry; then
        echo ""
        echo "❌ [ERROR] Failed to install Poetry after multiple attempts"
        echo ""
        echo "📋 Manual installation options:"
        echo "1. Install via pip (if you have Python 3.8+):"
        echo "   pip3 install --user poetry"
        echo ""
        echo "2. Install via official installer (retry):"
        echo "   curl -sSL https://install.python-poetry.org | python3 -"
        echo ""
        echo "3. Install via system package manager:"
        echo "   • Ubuntu/Debian: sudo apt install python3-poetry"
        echo "   • Fedora: sudo dnf install poetry"
        echo ""
        echo "4. If using older Python, upgrade first:"
        echo "   ./setup --upgrade-python"
        echo ""
        exit 1
    fi
fi

echo "✅ Poetry is available."

# Install project dependencies with better error handling  
echo "Installing project dependencies with Poetry... (This may take a moment)"

# Function to install dependencies with retry logic
install_dependencies() {
    local attempt=1
    local max_attempts=2
    
    while [ $attempt -le $max_attempts ]; do
        echo "📦 Installing dependencies (attempt $attempt/$max_attempts)..."
        
        # The poetry.toml file now handles all virtualenv configuration.
        # We just need to run install within an isolated subshell to avoid
        # conflicts with any externally activated virtual environments.
        if (
            unset VIRTUAL_ENV
            poetry install --no-ansi
        ); then
            echo "✅ Dependencies installed successfully"
            return 0
        else
            echo "❌ Dependency installation failed on attempt $attempt"
            
            if [ $attempt -lt $max_attempts ]; then
                echo "🔄 Retrying..."
                # Clear poetry cache and retry
                poetry cache clear --all . 2>/dev/null || true
                sleep 2
            fi
        fi
        
        attempt=$((attempt + 1))
    done
    
    return 1
}

if ! install_dependencies; then
    echo ""
    echo "❌ [ERROR] Failed to install project dependencies"
    echo ""
    echo "📋 This might be due to:"
    echo "1. Python version incompatibility (requires Python 3.8+)"
    echo "   Solution: Run './setup --upgrade-python'"
    echo ""
    echo "2. Network connectivity issues"
    echo "   Solution: Check internet connection and retry"
    echo ""
    echo "3. Poetry cache corruption"
    echo "   Solution: Run 'poetry cache clear --all .' and retry"
    echo ""
    echo "4. Missing system dependencies"
    echo "   Solution: Install build tools for your distribution"
    echo ""
    echo "💡 To retry just the dependency installation:"
    echo "   poetry install --no-ansi"
    echo ""
    exit 1
fi

# Make the wrapper script executable
chmod +x easy-opal

echo -e "\n✅ Setup complete! The environment is ready."

if [[ "$SKIP_MKCERT" == true ]]; then
    echo ""
    echo "⚠️  IMPORTANT: mkcert was skipped during setup."
    echo "   When running './easy-opal setup', choose one of these SSL strategies:"
    echo "   • 'manual' - Provide your own certificate files"
    echo "   • 'letsencrypt' - Use Let's Encrypt (requires public domain)"
    echo "   • 'reverse-proxy' - Use HTTP with external reverse proxy"
    echo ""
fi

echo "You can now run the tool using the './easy-opal' wrapper script."
echo "For example, to start the setup wizard, run:"

# ANSI escape codes
BOLD_YELLOW='\033[1;33m'
NC='\033[0m'
echo -e "${BOLD_YELLOW}./easy-opal setup${NC}" 