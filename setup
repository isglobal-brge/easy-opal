#!/bin/bash
# A simple script to set up the environment and install dependencies.

# Parse command line arguments
SKIP_MKCERT=false
UPGRADE_PYTHON=false
UPGRADE_DOCKER=false
for arg in "$@"; do
    case $arg in
        --skip-mkcert)
            SKIP_MKCERT=true
            shift
            ;;
        --upgrade-python)
            UPGRADE_PYTHON=true
            shift
            ;;
        --upgrade-docker)
            UPGRADE_DOCKER=true
            shift
            ;;
        --help|-h)
            echo "Usage: $0 [OPTIONS]"
            echo "Options:"
            echo "  --skip-mkcert      Skip mkcert installation (for manual SSL cert management)"
            echo "  --upgrade-python   Install/upgrade to Python 3.8+ if needed"
            echo "  --upgrade-docker   Install/upgrade Docker CE to latest version"
            echo "  --help, -h         Show this help message"
            echo ""
            echo "System Requirements:"
            echo "  - Python 3.8 or higher"
            echo "  - Docker 17.06+ required (20.10+ recommended)"
            echo "  - If you have older versions, use --upgrade-python or --upgrade-docker"
            exit 0
            ;;
        *)
            echo "Unknown option: $arg"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# ANSI color codes
RED='\033[1;31m'
GREEN='\033[1;32m'
LIME_GREEN='\033[38;5;46m'
BLUE='\033[1;34m'
YELLOW='\033[1;33m'
MAGENTA='\033[1;35m'
CYAN='\033[1;36m'
TURQUOISE='\033[38;5;73m'
ORANGE='\033[38;5;173m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Display header
echo ""
echo -e "${LIME_GREEN}=========================================================${NC}${LIME_GREEN}${BOLD}"
echo "                                                       _ "
echo "                                                      | |"
echo "  ___   __ _  ___  _   _           ___   _ __    __ _ | |"
echo " / _ \ / _\` |/ __|| | | | ______  / _ \ | '_ \  / _\` || |"
echo "|  __/| (_| |\__ \| |_| ||______|| (_) || |_) || (_| || |"
echo " \___| \__,_||___/ \__, |         \___/ | .__/  \__,_||_|"
echo "                    __/ |               | |              "
echo "                   |___/                |_|              "
echo -e "${NC}"
echo -e "${LIME_GREEN}=========================================================${NC}"
echo ""
echo -e "Made with ‚ù§Ô∏è  by ${BOLD}\033]8;;https://davidsarratgonzalez.github.io\007David Sarrat Gonz√°lez\033]8;;\007${NC}"
echo ""
echo -e "${TURQUOISE}${BOLD}\033]8;;https://brge.isglobal.org\007Bioinformatics Research Group in Epidemiology (BRGE)\033]8;;\007${NC}"
echo -e "${ORANGE}${BOLD}\033]8;;https://www.isglobal.org\007Barcelona Institute for Global Health (ISGlobal)\033]8;;\007${NC}"
echo ""

# Function to detect system information
detect_system() {
    # Detect OS
    OS="$(uname -s)"
    
    # Detect Linux distribution
    if [ "$OS" = "Linux" ] && [ -f /etc/os-release ]; then
        . /etc/os-release
        DISTRO="$ID"
        DISTRO_VERSION="$VERSION_ID"
        DISTRO_NAME="$PRETTY_NAME"
    else
        DISTRO="unknown"
        DISTRO_VERSION="unknown"
        DISTRO_NAME="$(uname -s) $(uname -r)"
    fi
    
    # Detect package manager
    if command -v apt-get &> /dev/null; then
        PKG_MANAGER="apt-get"
    elif command -v dnf &> /dev/null; then
        PKG_MANAGER="dnf"
    elif command -v yum &> /dev/null; then
        PKG_MANAGER="yum"
    elif command -v zypper &> /dev/null; then
        PKG_MANAGER="zypper"
    elif command -v pacman &> /dev/null; then
        PKG_MANAGER="pacman"
    elif command -v apk &> /dev/null; then
        PKG_MANAGER="apk"
    elif command -v pkg &> /dev/null; then
        PKG_MANAGER="pkg"
    elif command -v emerge &> /dev/null; then
        PKG_MANAGER="emerge"
    elif command -v xbps-install &> /dev/null; then
        PKG_MANAGER="xbps"
    elif command -v nix-env &> /dev/null; then
        PKG_MANAGER="nix"
    elif command -v swupd &> /dev/null; then
        PKG_MANAGER="swupd"
    elif command -v brew &> /dev/null; then
        PKG_MANAGER="brew"
    else
        PKG_MANAGER="unknown"
    fi
    
    echo "üñ•Ô∏è  System: $DISTRO_NAME"
    echo "üì¶ Package manager: $PKG_MANAGER"
}

# --- Dependency Checks ---

echo "--- Checking Prerequisites ---"
detect_system
echo ""

# Check for Python 3 and version
check_python_version() {
    if ! command -v python3 &> /dev/null; then
        echo "‚ùå [ERROR] 'python3' could not be found."
        echo "Please install Python 3 from https://www.python.org/downloads/ and try again."
        return 1
    fi

    # Debug: show which python3 we're using
    python3_path=$(which python3 2>/dev/null || echo "unknown")
    echo "üîç Using python3 from: $python3_path"

    # Get Python version
    python_version=$(python3 -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')" 2>/dev/null || echo "unknown")
    echo "üêç Python version: $python_version"

    # Check if version meets requirements (Python 3.8+)
    if python3 -c "import sys; exit(0 if sys.version_info >= (3, 8) else 1)" 2>/dev/null; then
        echo "‚úÖ Python version is compatible"

        # On macOS, check if Python can create venvs (CommandLineTools Python has limitations)
        if [[ "$(uname -s)" == "Darwin" ]]; then
            if ! python3 -c "import venv; venv.EnvBuilder().create('/tmp/venv_test_$$')" 2>/dev/null; then
                rm -rf "/tmp/venv_test_$$" 2>/dev/null
                echo "‚ö†Ô∏è  Warning: Your Python cannot create virtual environments"
                echo "   This is common with macOS CommandLineTools Python."
                return 3
            fi
            rm -rf "/tmp/venv_test_$$" 2>/dev/null
        fi

        return 0
    else
        echo "‚ö†Ô∏è  Python $python_version detected. Python 3.8+ is required"
        return 2
    fi
}

# Function to set up Python alternatives (cross-platform)
setup_python_alternatives() {
    local python_path="$1"
    local pip_path="$2"
    
    echo "üîß Setting up Python alternatives..."
    
    # Method 1: Try update-alternatives (most common)
    if command -v update-alternatives &> /dev/null; then
        echo "Using update-alternatives..."
        if sudo update-alternatives --install /usr/bin/python3 python3 "$python_path" 100 2>/dev/null && \
           sudo update-alternatives --install /usr/bin/pip3 pip3 "$pip_path" 100 2>/dev/null; then
            sudo update-alternatives --set python3 "$python_path" 2>/dev/null || true
            sudo update-alternatives --set pip3 "$pip_path" 2>/dev/null || true
            return 0
        fi
    fi
    
    # Method 2: Try alternatives (older RHEL/CentOS)
    if command -v alternatives &> /dev/null; then
        echo "Using alternatives (legacy)..."
        if sudo alternatives --install /usr/bin/python3 python3 "$python_path" 100 2>/dev/null && \
           sudo alternatives --install /usr/bin/pip3 pip3 "$pip_path" 100 2>/dev/null; then
            sudo alternatives --set python3 "$python_path" 2>/dev/null || true
            sudo alternatives --set pip3 "$pip_path" 2>/dev/null || true
            return 0
        fi
    fi
    
    # Method 3: Direct symlinks (fallback for all systems)
    echo "Using direct symlinks as fallback..."
    if sudo ln -sf "$python_path" /usr/bin/python3 2>/dev/null && \
       sudo ln -sf "$pip_path" /usr/bin/pip3 2>/dev/null; then
        return 0
    fi
    
    # Method 4: Try /usr/local/bin symlinks (for systems where /usr/bin is protected)
    echo "Trying /usr/local/bin symlinks..."
    sudo mkdir -p /usr/local/bin
    if sudo ln -sf "$python_path" /usr/local/bin/python3 2>/dev/null && \
       sudo ln -sf "$pip_path" /usr/local/bin/pip3 2>/dev/null; then
        # Ensure /usr/local/bin is in PATH
        if ! echo "$PATH" | grep -q "/usr/local/bin"; then
            export PATH="/usr/local/bin:$PATH"
            echo 'export PATH="/usr/local/bin:$PATH"' >> ~/.bashrc
        fi
        return 0
    fi
    
    echo "‚ö†Ô∏è  Warning: Could not set up Python alternatives automatically"
    echo "Manual setup may be required."
    return 1
}

# Function to check Docker version
check_docker_version() {
    if ! command -v docker &> /dev/null; then
        echo "‚ùå [ERROR] 'docker' could not be found."
        return 1
    fi

    # Debug: show which docker we're using
    docker_path=$(which docker 2>/dev/null || echo "unknown")
    echo "üîç Using docker from: $docker_path"

    # Get Docker version
    docker_version=$(docker --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    echo "üê≥ Docker version: $docker_version"

    # Check if version meets requirements (Docker 17.06+)
    if docker version --format '{{.Server.Version}}' &>/dev/null; then
        server_version=$(docker version --format '{{.Server.Version}}' 2>/dev/null | grep -oE '[0-9]+\.[0-9]+' | head -1)
        if [[ -n "$server_version" ]]; then
            major=$(echo "$server_version" | cut -d. -f1)
            minor=$(echo "$server_version" | cut -d. -f2)
            if [[ $major -gt 17 ]] || [[ $major -eq 17 && $minor -ge 6 ]]; then
                echo "‚úÖ Docker version is compatible"
                return 0
            else
                echo "‚ö†Ô∏è  Docker $server_version detected. Docker 17.06+ recommended"
                return 2
            fi
        fi
    fi

    # Fallback version check
    if [[ -n "$docker_version" ]]; then
        major=$(echo "$docker_version" | cut -d. -f1)
        minor=$(echo "$docker_version" | cut -d. -f2)
        if [[ $major -gt 17 ]] || [[ $major -eq 17 && $minor -ge 6 ]]; then
            echo "‚úÖ Docker version is compatible"
            return 0
        else
            echo "‚ö†Ô∏è  Docker $docker_version detected. Docker 17.06+ recommended"
            return 2
        fi
    fi

    echo "‚ö†Ô∏è  Could not determine Docker version. Proceeding with caution."
    return 2
}

# Function to check Docker Compose availability
check_docker_compose() {
    echo ""
    echo "--- Checking Docker Compose ---"

    # Check for Docker Compose V2 (docker compose)
    if docker compose version &>/dev/null; then
        compose_version=$(docker compose version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        echo "‚úÖ Docker Compose V2 found: $compose_version"
        return 0
    fi

    # Check for Docker Compose V1 (docker-compose)
    if command -v docker-compose &>/dev/null; then
        compose_version=$(docker-compose --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        echo "‚úÖ Docker Compose V1 found: $compose_version"
        echo "‚ö†Ô∏è  Note: Docker Compose V2 is recommended for better performance"
        return 0
    fi

    echo "‚ùå [ERROR] Docker Compose not found"
    return 1
}

# Function to install Docker Compose
install_docker_compose() {
    echo "üì¶ Installing Docker Compose..."
    OS="$(uname -s)"

    if [ "$OS" = "Darwin" ]; then
        echo "Docker Compose should be included with Docker Desktop on macOS."
        echo "Please ensure Docker Desktop is properly installed."
        return 1
    fi

    # Detect Linux distribution
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        DISTRO=$ID
    else
        DISTRO="unknown"
    fi

    # Try to install docker-compose-plugin (V2)
    case "$DISTRO" in
        ubuntu|debian)
            echo "Installing docker-compose-plugin via apt..."
            if sudo apt-get update && sudo apt-get install -y docker-compose-plugin 2>/dev/null; then
                echo "‚úÖ Docker Compose V2 installed"
                return 0
            fi
            ;;
        fedora)
            echo "Installing docker-compose-plugin via dnf..."
            if sudo dnf install -y docker-compose-plugin 2>/dev/null; then
                echo "‚úÖ Docker Compose V2 installed"
                return 0
            fi
            ;;
        centos|rhel|rocky|almalinux)
            echo "Installing docker-compose-plugin via dnf/yum..."
            if command -v dnf &>/dev/null; then
                sudo dnf install -y docker-compose-plugin 2>/dev/null && return 0
            elif command -v yum &>/dev/null; then
                sudo yum install -y docker-compose-plugin 2>/dev/null && return 0
            fi
            ;;
        arch|manjaro)
            echo "Installing docker-compose via pacman..."
            if sudo pacman -S --noconfirm docker-compose 2>/dev/null; then
                echo "‚úÖ Docker Compose installed"
                return 0
            fi
            ;;
        alpine)
            echo "Installing docker-compose via apk..."
            if sudo apk add docker-compose 2>/dev/null; then
                echo "‚úÖ Docker Compose installed"
                return 0
            fi
            ;;
    esac

    # Fallback: Download docker-compose binary directly
    echo "Attempting to download Docker Compose binary..."
    ARCH="$(uname -m)"
    case "$ARCH" in
        x86_64) ARCH="x86_64" ;;
        aarch64|arm64) ARCH="aarch64" ;;
        armv7l) ARCH="armv7" ;;
        *)
            echo "‚ö†Ô∏è  Unsupported architecture for binary download: $ARCH"
            return 1
            ;;
    esac

    # Get latest compose version
    COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    if [ -z "$COMPOSE_VERSION" ]; then
        COMPOSE_VERSION="v2.24.0"  # Fallback version
    fi

    COMPOSE_URL="https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-linux-${ARCH}"

    echo "Downloading Docker Compose ${COMPOSE_VERSION}..."
    if curl -L -o /tmp/docker-compose "$COMPOSE_URL" 2>/dev/null; then
        sudo chmod +x /tmp/docker-compose
        sudo mv /tmp/docker-compose /usr/local/bin/docker-compose
        echo "‚úÖ Docker Compose installed to /usr/local/bin/docker-compose"
        return 0
    fi

    echo "‚ùå Failed to install Docker Compose"
    return 1
}

# Function to check Docker permissions
check_docker_permissions() {
    echo ""
    echo "--- Checking Docker Permissions ---"

    # Try to run docker without sudo
    if docker ps &>/dev/null; then
        echo "‚úÖ Docker is accessible without sudo"
        return 0
    fi

    # Check if user is in docker group
    if groups | grep -q docker; then
        echo "‚ö†Ô∏è  User is in docker group but docker daemon may not be running"
        echo "   Try: sudo systemctl start docker"
        return 1
    fi

    # Check if docker works with sudo
    if sudo docker ps &>/dev/null; then
        echo "‚ö†Ô∏è  Docker requires sudo. For better experience, add user to docker group:"
        echo "   sudo usermod -aG docker \$USER"
        echo "   Then log out and back in."
        echo ""
        echo "   Continuing with sudo for now..."
        return 0
    fi

    echo "‚ùå Docker daemon is not running or not accessible"
    echo "   Try: sudo systemctl start docker"
    return 1
}

# Function to install Docker CE on different distributions
install_docker() {
    echo "üê≥ Installing Docker CE for your system..."
    OS="$(uname -s)"
    
    if [ "$OS" = "Darwin" ]; then
        echo "‚ùå Docker Desktop for macOS requires manual installation."
        echo "Please download and install Docker Desktop from:"
        echo "https://www.docker.com/products/docker-desktop/"
        echo ""
        echo "After installation, re-run this script."
        return 1
    fi
    
    # Detect Linux distribution
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        DISTRO=$ID
        DISTRO_VERSION=$VERSION_ID
    else
        DISTRO="unknown"
    fi
    
    case "$DISTRO" in
        ubuntu)
            echo "Installing Docker CE on Ubuntu $DISTRO_VERSION..."
            
            # Remove old Docker packages
            sudo apt-get remove -y docker docker-engine docker.io containerd runc 2>/dev/null || true
            
            # Update package index
            sudo apt-get update
            
            # Install prerequisites
            sudo apt-get install -y ca-certificates curl gnupg lsb-release
            
            # Add Docker's official GPG key
            sudo mkdir -p /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            
            # Set up repository
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            # Install Docker Engine
            sudo apt-get update
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
            ;;
            
        debian)
            echo "Installing Docker CE on Debian $DISTRO_VERSION..."
            
            # Remove old Docker packages
            sudo apt-get remove -y docker docker-engine docker.io containerd runc 2>/dev/null || true
            
            # Update package index
            sudo apt-get update
            
            # Install prerequisites
            sudo apt-get install -y ca-certificates curl gnupg lsb-release
            
            # Add Docker's official GPG key
            sudo mkdir -p /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            
            # Set up repository
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            # Install Docker Engine
            sudo apt-get update
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
            ;;
            
        fedora)
            echo "Installing Docker CE on Fedora $DISTRO_VERSION..."
            
            # Remove old Docker packages
            sudo dnf remove -y docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-selinux docker-engine-selinux docker-engine 2>/dev/null || true
            
            # Install prerequisites
            sudo dnf install -y dnf-plugins-core
            
            # Add Docker repository
            sudo dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo
            
            # Install Docker Engine
            sudo dnf install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
            ;;
            
        centos|rhel|rocky|almalinux)
            echo "Installing Docker CE on RHEL-based system $DISTRO_VERSION..."
            
            # Check version compatibility
            major_version=$(echo "$DISTRO_VERSION" | cut -d. -f1)
            if [[ $major_version -lt 8 ]]; then
                echo "‚ö†Ô∏è  Docker CE requires CentOS/RHEL 8+. Your version: $DISTRO_VERSION"
                echo "For older versions, please install Docker manually:"
                echo "https://docs.docker.com/engine/install/centos/"
                return 1
            fi
            
            # Remove old Docker packages
            if command -v dnf &> /dev/null; then
                sudo dnf remove -y docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine podman runc 2>/dev/null || true
                
                # Install prerequisites
                sudo dnf install -y dnf-plugins-core
                
                # Add Docker repository
                sudo dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
                
                # Install Docker Engine
                sudo dnf install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
            else
                echo "‚ùå dnf not found. CentOS 7 and below require manual Docker installation."
                return 1
            fi
            ;;
            
        arch|manjaro)
            echo "Installing Docker on Arch-based system..."
            
            # Install Docker from community repository
            sudo pacman -S --noconfirm docker docker-compose
            ;;
            
        opensuse*|sles)
            echo "Installing Docker CE on openSUSE/SLES..."
            
            # Add Docker repository
            sudo zypper addrepo https://download.docker.com/linux/sles/docker-ce.repo
            sudo zypper refresh
            
            # Install Docker Engine
            sudo zypper install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
            ;;
            
        alpine)
            echo "Installing Docker on Alpine Linux..."
            
            # Install Docker from community repository
            sudo apk update
            sudo apk add docker docker-compose
            ;;
            
        void)
            echo "Installing Docker on Void Linux..."
            
            # Install Docker from repositories
            sudo xbps-install -y docker docker-compose
            ;;
            
        gentoo)
            echo "Installing Docker on Gentoo..."
            
            # Install Docker via Portage
            sudo emerge --ask=n app-containers/docker app-containers/docker-compose
            
            # Add user to docker group
            sudo gpasswd -a $(whoami) docker
            ;;
            
        nixos)
            echo "Installing Docker on NixOS..."
            echo "‚ö†Ô∏è  NixOS requires system configuration for Docker:"
            echo "1. Add to /etc/nixos/configuration.nix:"
            echo "   virtualisation.docker.enable = true;"
            echo "   users.users.$(whoami).extraGroups = [ \"docker\" ];"
            echo "2. Run: sudo nixos-rebuild switch"
            echo "3. Log out and back in for group changes"
            echo "4. Re-run this script after system rebuild"
            echo ""
            return 1
            ;;
            
        clear-linux-os)
            echo "Installing Docker on Clear Linux..."
            
            # Install Docker bundle
            sudo swupd bundle-add containers-basic
            
            # Enable and start Docker service
            sudo systemctl enable docker
            sudo systemctl start docker
            ;;
            
        freebsd)
            echo "Installing container runtime on FreeBSD..."
            echo "‚ö†Ô∏è  Docker doesn't run natively on FreeBSD. Available options:"
            echo ""
            echo "üìã Option 1: Use Podman (Docker-compatible)"
            echo "   sudo pkg install podman"
            echo "   # Then use 'podman' instead of 'docker'"
            echo ""
            echo "üìã Option 2: Use Linux compatibility layer"
            echo "   sudo pkg install linux-c7-docker-ce"
            echo "   # Requires Linux compatibility enabled"
            echo ""
            echo "üìã Option 3: Use bhyve VM with Linux + Docker"
            echo "   # Set up a Linux VM for Docker workloads"
            echo ""
            echo "For this setup script, we recommend using Podman:"
            
            if sudo pkg install -y podman; then
                echo "‚úÖ Podman installed successfully"
                echo "üí° Note: Use 'podman' commands instead of 'docker'"
                echo "   You can alias: alias docker=podman"
                return 0
            else
                echo "‚ùå Failed to install Podman"
                return 1
            fi
            ;;
            
        *)
            echo "‚ùå Automatic Docker installation not supported for $DISTRO"
            echo ""
            echo "üìã Manual installation required:"
            echo "1. Visit: https://docs.docker.com/engine/install/"
            echo "2. Select your distribution"
            echo "3. Follow the installation guide"
            echo "4. Re-run this script after Docker is installed"
            echo ""
            return 1
            ;;
    esac
    
    # Start and enable Docker service
    echo "üîß Starting Docker service..."
    if command -v systemctl &> /dev/null; then
        sudo systemctl start docker
        sudo systemctl enable docker
    elif command -v service &> /dev/null; then
        sudo service docker start
    elif command -v rc-service &> /dev/null; then
        sudo rc-service docker start
        sudo rc-update add docker default
    fi
    
    # Add current user to docker group
    echo "üë§ Adding user $(whoami) to docker group..."
    sudo usermod -aG docker $(whoami)
    
    # Verify installation
    echo "üîç Verifying Docker installation..."
    sleep 2  # Give Docker service time to start
    
    if docker --version &>/dev/null; then
        docker_version=$(docker --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        echo "‚úÖ Docker $docker_version installed successfully"
        
        echo ""
        echo "‚ö†Ô∏è  IMPORTANT: You need to log out and back in (or restart) for docker group changes to take effect."
        echo "After logging back in, you should be able to run 'docker ps' without sudo."
        echo ""
        return 0
    else
        echo "‚ùå Docker installation verification failed"
        return 1
    fi
}

# Function to install Python 3.8+ on different distributions
install_newer_python() {
    echo "üîÑ Installing Python 3.8+ for your system..."
    OS="$(uname -s)"
    
    if [ "$OS" = "Darwin" ]; then
        echo "Installing Python via Homebrew..."
        if command -v brew &> /dev/null; then
            brew install python@3.11
            echo "‚úÖ Python 3.11 installed via Homebrew"
            echo "You may need to update your PATH or use 'python3.11' directly"
        else
            echo "‚ùå Homebrew not found. Please install it first or install Python manually."
            return 1
        fi
        return 0
    fi
    
    # Detect Linux distribution
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        DISTRO=$ID
    else
        DISTRO="unknown"
    fi
    
    case "$DISTRO" in
                 ubuntu|debian)
             echo "Installing Python 3.11 via deadsnakes PPA..."
             sudo apt-get update
             sudo apt-get install -y software-properties-common
             sudo add-apt-repository ppa:deadsnakes/ppa -y
             sudo apt-get update
             sudo apt-get install -y python3.11 python3.11-venv python3.11-pip python3.11-dev
             
             # Verify installation
             if ! python3.11 --version &> /dev/null; then
                 echo "‚ùå Failed to install Python 3.11"
                 return 1
             fi
             
             echo "‚úÖ Python 3.11 installed successfully"
             echo "Setting python3.11 as default python3..."
             setup_python_alternatives "/usr/bin/python3.11" "/usr/bin/pip3.11"
             ;;
            
        fedora)
            echo "Installing Python 3.11 via dnf..."
            sudo dnf install -y python3.11 python3.11-pip python3.11-devel
            
            if ! python3.11 --version &> /dev/null; then
                echo "‚ùå Failed to install Python 3.11"
                return 1
            fi
            
            echo "‚úÖ Python 3.11 installed successfully"
            echo "Setting python3.11 as default python3..."
            setup_python_alternatives "/usr/bin/python3.11" "/usr/bin/pip3.11"
            ;;
            
                 centos|rhel|rocky|almalinux)
             echo "Installing Python 3.11 on RHEL/CentOS-based system..."
             
             # Try different methods based on version
             if command -v dnf &> /dev/null; then
                 # Try EPEL and PowerTools first
                 sudo dnf install -y epel-release
                 sudo dnf config-manager --set-enabled powertools 2>/dev/null || sudo dnf config-manager --set-enabled PowerTools 2>/dev/null || true
                 
                 if sudo dnf install -y python3.11 python3.11-pip python3.11-devel 2>/dev/null; then
                     echo "‚úÖ Python 3.11 installed via dnf"
                     setup_python_alternatives "/usr/bin/python3.11" "/usr/bin/pip3.11"
                 else
                     echo "Trying alternative installation method..."
                     install_python_from_source "3.11.7"
                 fi
             elif command -v yum &> /dev/null; then
                 # For older CentOS versions, first try to install Python 3.11 from EPEL
                 sudo yum install -y epel-release
                                   if sudo yum install -y python3.11 python3.11-pip python3.11-devel 2>/dev/null; then
                      echo "‚úÖ Python 3.11 installed via yum"
                      setup_python_alternatives "/usr/bin/python3.11" "/usr/bin/pip3.11"
                 else
                     # Fallback to Software Collections or source
                     if yum list available | grep -q rh-python38; then
                         sudo yum install -y centos-release-scl
                         sudo yum install -y rh-python38 rh-python38-python-pip rh-python38-python-devel
                         echo "‚úÖ Python 3.8 installed via Software Collections"
                         
                         # Create wrapper scripts that enable SCL
                         sudo tee /usr/local/bin/python3 > /dev/null << 'EOF'
#!/bin/bash
source /opt/rh/rh-python38/enable
exec python3 "$@"
EOF
                         sudo tee /usr/local/bin/pip3 > /dev/null << 'EOF'
#!/bin/bash
source /opt/rh/rh-python38/enable
exec pip3 "$@"
EOF
                         sudo chmod +x /usr/local/bin/python3 /usr/local/bin/pip3
                         export PATH="/usr/local/bin:$PATH"
                     else
                         echo "Installing Python from source..."
                         install_python_from_source "3.11.7"
                     fi
                 fi
             fi
             ;;
            
        opensuse*|sles)
            echo "Installing Python 3.11 via zypper..."
            sudo zypper install -y python311 python311-pip python311-devel
            
            if ! python3.11 --version &> /dev/null; then
                echo "‚ùå Failed to install Python 3.11"
                return 1
            fi
            
            echo "‚úÖ Python 3.11 installed successfully"
            setup_python_alternatives "/usr/bin/python3.11" "/usr/bin/pip3.11"
            ;;
            
        arch|manjaro)
            echo "Installing Python via pacman..."
            sudo pacman -S --noconfirm python python-pip
            echo "‚úÖ Python installed successfully"
            # Arch usually has the latest Python as default, but let's verify
            if ! python3 -c "import sys; exit(0 if sys.version_info >= (3, 8) else 1)" 2>/dev/null; then
                echo "‚ö†Ô∏è  Arch Python version might be too old, trying python3.11..."
                sudo pacman -S --noconfirm python311 python311-pip 2>/dev/null || true
                setup_python_alternatives "/usr/bin/python3.11" "/usr/bin/pip3.11"
            fi
            ;;
            
        alpine)
            echo "Installing Python 3.11 on Alpine Linux..."
            sudo apk update
            sudo apk add python3 python3-dev py3-pip
            echo "‚úÖ Python installed successfully"
            # Alpine usually has recent Python, but verify
            if ! python3 -c "import sys; exit(0 if sys.version_info >= (3, 8) else 1)" 2>/dev/null; then
                echo "‚ö†Ô∏è  Alpine Python might be too old, trying source installation..."
                install_python_from_source "3.11.7"
            fi
            ;;
            
        void)
            echo "Installing Python 3.11 on Void Linux..."
            sudo xbps-install -y python3 python3-devel python3-pip
            echo "‚úÖ Python installed successfully"
            # Void usually has recent Python
            if ! python3 -c "import sys; exit(0 if sys.version_info >= (3, 8) else 1)" 2>/dev/null; then
                echo "‚ö†Ô∏è  Void Python might be too old, trying source installation..."
                install_python_from_source "3.11.7"
            fi
            ;;
            
        gentoo)
            echo "Installing Python 3.11 on Gentoo..."
            # Gentoo users typically manage Python versions themselves
            echo "‚ö†Ô∏è  Gentoo detected. You likely need to configure Python manually:"
            echo "1. Check available Python versions: eselect python list"
            echo "2. Install Python 3.11: emerge -av =dev-lang/python-3.11*"
            echo "3. Set as default: eselect python set python3.11"
            echo "4. Re-run this script after Python setup"
            return 1
            ;;
            
        nixos)
            echo "Installing Python 3.11 on NixOS..."
            echo "‚ö†Ô∏è  NixOS detected. Please add Python 3.11+ to your system configuration:"
            echo "1. Add to /etc/nixos/configuration.nix:"
            echo "   environment.systemPackages = with pkgs; [ python311 python311Packages.pip ];"
            echo "2. Run: sudo nixos-rebuild switch"
            echo "3. Re-run this script after system rebuild"
            return 1
            ;;
            
        clear-linux-os)
            echo "Installing Python 3.11 on Clear Linux..."
            sudo swupd bundle-add python3-basic python-basic-dev
            echo "‚úÖ Python installed successfully"
            # Clear Linux usually has recent Python
            if ! python3 -c "import sys; exit(0 if sys.version_info >= (3, 8) else 1)" 2>/dev/null; then
                echo "‚ö†Ô∏è  Clear Linux Python might be too old, trying source installation..."  
                install_python_from_source "3.11.7"
            fi
            ;;
            
        *)
            echo "Unknown distribution: $DISTRO"
            echo "Attempting to install Python from source..."
            install_python_from_source "3.11.7"
            ;;
    esac
    
    # Verify that python3 now points to the new version
    echo "üîç Verifying Python 3 installation..."
    hash -r  # Clear command hash table
    export PATH="/usr/local/bin:$PATH"  # Ensure /usr/local/bin is prioritized
    
    sleep 1  # Give the system a moment to update
    
    new_python_version=$(python3 -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')" 2>/dev/null || echo "unknown")
    if python3 -c "import sys; exit(0 if sys.version_info >= (3, 8) else 1)" 2>/dev/null; then
        echo "‚úÖ Verification successful: python3 now points to version $new_python_version"
        return 0
    else
        echo "‚ö†Ô∏è  Warning: python3 still points to version $new_python_version (< 3.8)"
        echo "This may require a shell restart or manual PATH update."
        return 1
    fi
}

# Function to install Python from source (fallback method)
install_python_from_source() {
    local python_version=${1:-"3.11.7"}
    echo "üì¶ Installing Python $python_version from source..."
    
    # Install build dependencies
    if command -v apt-get &> /dev/null; then
        sudo apt-get update
        sudo apt-get install -y build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libsqlite3-dev wget libbz2-dev
    elif command -v dnf &> /dev/null; then
        sudo dnf groupinstall -y "Development Tools"
        sudo dnf install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel expat-devel
    elif command -v yum &> /dev/null; then
        sudo yum groupinstall -y "Development Tools"
        sudo yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel expat-devel
    elif command -v zypper &> /dev/null; then
        sudo zypper install -y gcc gcc-c++ make zlib-devel libbz2-devel libopenssl-devel libffi-devel sqlite3-devel ncurses-devel readline-devel wget
    elif command -v pacman &> /dev/null; then
        sudo pacman -S --noconfirm base-devel zlib bzip2 openssl libffi sqlite ncurses readline wget
    elif command -v apk &> /dev/null; then
        sudo apk add build-base zlib-dev bzip2-dev openssl-dev libffi-dev sqlite-dev ncurses-dev readline-dev wget
    elif command -v xbps-install &> /dev/null; then
        sudo xbps-install -y base-devel zlib-devel bzip2-devel openssl-devel libffi-devel sqlite-devel ncurses-devel readline-devel wget
    elif command -v emerge &> /dev/null; then
        sudo emerge --ask=n sys-devel/gcc sys-devel/make sys-libs/zlib app-arch/bzip2 dev-libs/openssl dev-libs/libffi dev-db/sqlite sys-libs/ncurses sys-libs/readline net-misc/wget
    elif command -v swupd &> /dev/null; then
        sudo swupd bundle-add c-basic devpkg-zlib devpkg-bzip2 devpkg-openssl devpkg-libffi devpkg-sqlite devpkg-ncurses devpkg-readline
    fi
    
    # Download and compile Python
    cd /tmp
    wget https://www.python.org/ftp/python/$python_version/Python-$python_version.tgz
    tar xzf Python-$python_version.tgz
    cd Python-$python_version
    
    ./configure --enable-optimizations --prefix=/usr/local
    make -j $(nproc)
    sudo make altinstall
    
    # Set up alternatives for source-compiled Python
    setup_python_alternatives "/usr/local/bin/python3.11" "/usr/local/bin/pip3.11"
    
    # Update PATH
    echo 'export PATH="/usr/local/bin:$PATH"' >> ~/.bashrc
    export PATH="/usr/local/bin:$PATH"
    
    # Clean up
    cd /
    rm -rf /tmp/Python-$python_version*
    
    echo "‚úÖ Python $python_version installed from source in /usr/local"
    echo "You may need to restart your shell or run: source ~/.bashrc"
}

# Main Python check - but don't fail immediately if version is old
# uv can install Python automatically later
python_check_result=0
check_python_version || python_check_result=$?

# Store the result for later - we'll use uv to fix Python issues if needed
PYTHON_NEEDS_UPGRADE=false

if [ $python_check_result -eq 1 ]; then
    # Python not found at all - this is critical, we need at least basic Python
    echo ""
    echo "‚ö†Ô∏è  No Python 3 found. Will attempt to use uv to install Python later..."
    PYTHON_NEEDS_UPGRADE=true
elif [ $python_check_result -eq 2 ]; then
    # Python found but version too old
    if [ "$UPGRADE_PYTHON" = true ]; then
        echo "üöÄ Upgrading Python as requested..."
        if install_newer_python; then
            echo "‚úÖ Python upgrade completed"
            echo "üîÑ Re-checking Python version..."

            # Refresh command hash and PATH
            hash -r
            export PATH="/usr/local/bin:$PATH"

            # Re-run the Python version check
            if check_python_version; then
                echo "‚úÖ Python upgrade verification successful"
            else
                echo "‚ùå Python upgrade verification failed"
                echo ""
                echo "The newer Python was installed but python3 still points to the old version."
                echo "Will attempt to use uv to manage Python later..."
                PYTHON_NEEDS_UPGRADE=true
            fi
        else
            echo "‚ö†Ô∏è  Manual Python upgrade failed. Will attempt to use uv to install Python later..."
            PYTHON_NEEDS_UPGRADE=true
        fi
    else
        echo ""
        echo "‚ö†Ô∏è  Python version is too old. Will attempt to use uv to install Python later..."
        PYTHON_NEEDS_UPGRADE=true
    fi
elif [ $python_check_result -eq 3 ]; then
    # macOS: Python cannot create venvs (CommandLineTools limitation)
    echo ""
    echo "‚ö†Ô∏è  Your Python cannot create virtual environments."
    echo "   Will attempt to use uv to manage Python later..."
    PYTHON_NEEDS_UPGRADE=true
fi

# Main Docker check
docker_check_result=0
check_docker_version || docker_check_result=$?

if [ $docker_check_result -eq 1 ]; then
    # Docker not found at all
    if [ "$UPGRADE_DOCKER" = true ]; then
        echo "üöÄ Installing Docker as requested..."
        if install_docker; then
            echo "‚úÖ Docker installation completed"
            echo "üîÑ Re-checking Docker version..."
            
            # Re-run the Docker version check
            if check_docker_version; then
                echo "‚úÖ Docker installation verification successful"
            else
                echo "‚ùå Docker installation verification failed"
                echo ""
                echo "üìã Troubleshooting steps:"
                echo "1. Log out and back in to refresh group membership"
                echo "2. Restart your system if needed"
                echo "3. Check: docker --version"
                echo "4. Re-run: ./setup"
                echo ""
                exit 1
            fi
        else
            echo "‚ùå Failed to install Docker"
            exit 1
        fi
    else
        echo "Please install Docker Desktop from https://www.docker.com/products/docker-desktop and try again."
        echo ""
        echo "üìã Options to resolve this:"
        echo "1. Re-run with --upgrade-docker to automatically install Docker CE"
        echo "2. Install Docker manually from the official website"
        echo "3. Use your distribution's package manager"
        echo ""
        exit 1
    fi
elif [ $docker_check_result -eq 2 ]; then
    # Docker found but version might be old
    if [ "$UPGRADE_DOCKER" = true ]; then
        echo "üöÄ Upgrading Docker as requested..."
        if install_docker; then
            echo "‚úÖ Docker upgrade completed"
            echo "üîÑ Re-checking Docker version..."

            # Re-run the Docker version check
            if check_docker_version; then
                echo "‚úÖ Docker upgrade verification successful"
            else
                echo "‚ùå Docker upgrade verification failed"
                exit 1
            fi
        else
            echo "‚ùå Failed to upgrade Docker"
            exit 1
        fi
    else
        echo ""
        echo "üìã Docker version information:"
        echo "‚Ä¢ Minimum supported: Docker 17.06"
        echo "‚Ä¢ Recommended: Docker 20.10+"
        echo "‚Ä¢ To upgrade: ./setup --upgrade-docker"
        echo ""
        echo "Continuing with current Docker version..."
    fi
fi

# Check Docker Compose
if ! check_docker_compose; then
    echo "Attempting to install Docker Compose..."
    if ! install_docker_compose; then
        echo ""
        echo "‚ùå [ERROR] Docker Compose is required but could not be installed"
        echo ""
        echo "üìã Manual installation options:"
        echo "  ‚Ä¢ Ubuntu/Debian: sudo apt install docker-compose-plugin"
        echo "  ‚Ä¢ Fedora: sudo dnf install docker-compose-plugin"
        echo "  ‚Ä¢ Or download from: https://github.com/docker/compose/releases"
        echo ""
        exit 1
    fi
fi

# Check Docker permissions
if ! check_docker_permissions; then
    echo ""
    echo "‚ö†Ô∏è  Docker permission issues detected"
    echo "The setup will continue, but you may need to use 'sudo' with docker commands"
    echo "or fix permissions by adding your user to the docker group."
    echo ""
fi

# Check for Git
if ! command -v git &> /dev/null; then
    echo "‚ùå [ERROR] 'git' could not be found."
    echo "Attempting to install git..."
    if [[ "$(uname -s)" == "Darwin" ]]; then
        # On macOS, git is often installed via Xcode Command Line Tools, which brew can trigger.
        brew install git
    elif command -v apt-get &> /dev/null; then
        sudo apt-get update && sudo apt-get install -y git
    elif command -v dnf &> /dev/null; then
        sudo dnf install -y git
    elif command -v yum &> /dev/null; then
        sudo yum install -y git
    elif command -v zypper &> /dev/null; then
        sudo zypper install -y git
    elif command -v pacman &> /dev/null; then
        sudo pacman -S --noconfirm git
    elif command -v apk &> /dev/null; then
        sudo apk add git
    elif command -v pkg &> /dev/null; then
        sudo pkg install -y git
    elif command -v emerge &> /dev/null; then
        sudo emerge --ask=n dev-vcs/git
    elif command -v xbps-install &> /dev/null; then
        sudo xbps-install -y git
    elif command -v nix-env &> /dev/null; then
        nix-env -iA nixpkgs.git
    elif command -v swupd &> /dev/null; then
        sudo swupd bundle-add git
    else
        echo "Could not install git automatically. Please install it manually."
        echo "Common commands:"
        echo "  ‚Ä¢ Ubuntu/Debian: sudo apt install git"
        echo "  ‚Ä¢ Fedora: sudo dnf install git"
        echo "  ‚Ä¢ CentOS/RHEL: sudo yum install git"
        echo "  ‚Ä¢ openSUSE: sudo zypper install git"
        echo "  ‚Ä¢ Arch: sudo pacman -S git"
        echo "  ‚Ä¢ Alpine: sudo apk add git"
        echo "  ‚Ä¢ FreeBSD: sudo pkg install git"
        echo "  ‚Ä¢ Gentoo: sudo emerge dev-vcs/git"
        echo "  ‚Ä¢ Void: sudo xbps-install git"
        echo "  ‚Ä¢ NixOS: nix-env -iA nixpkgs.git"
        echo "  ‚Ä¢ Clear Linux: sudo swupd bundle-add git"
        exit 1
    fi
fi
echo "‚úÖ Git found."

# Check for curl
if ! command -v curl &> /dev/null; then
    echo "‚ùå [ERROR] 'curl' could not be found."
    echo "Attempting to install curl..."
    if [[ "$(uname -s)" == "Darwin" ]]; then
        # On macOS, curl is usually pre-installed, but just in case
        brew install curl
    elif command -v apt-get &> /dev/null; then
        sudo apt-get update && sudo apt-get install -y curl
    elif command -v dnf &> /dev/null; then
        sudo dnf install -y curl
    elif command -v yum &> /dev/null; then
        sudo yum install -y curl
    elif command -v zypper &> /dev/null; then
        sudo zypper install -y curl
    elif command -v pacman &> /dev/null; then
        sudo pacman -S --noconfirm curl
    elif command -v apk &> /dev/null; then
        sudo apk add curl
    elif command -v pkg &> /dev/null; then
        sudo pkg install -y curl
    elif command -v emerge &> /dev/null; then
        sudo emerge --ask=n net-misc/curl
    elif command -v xbps-install &> /dev/null; then
        sudo xbps-install -y curl
    elif command -v nix-env &> /dev/null; then
        nix-env -iA nixpkgs.curl
    elif command -v swupd &> /dev/null; then
        sudo swupd bundle-add curl
    else
        echo "Could not install curl automatically. Please install it manually."
        echo "Common commands:"
        echo "  ‚Ä¢ Ubuntu/Debian: sudo apt install curl"
        echo "  ‚Ä¢ Fedora: sudo dnf install curl" 
        echo "  ‚Ä¢ CentOS/RHEL: sudo yum install curl"
        echo "  ‚Ä¢ openSUSE: sudo zypper install curl"
        echo "  ‚Ä¢ Arch: sudo pacman -S curl"
        echo "  ‚Ä¢ Alpine: sudo apk add curl"
        echo "  ‚Ä¢ FreeBSD: sudo pkg install curl"
        echo "  ‚Ä¢ Gentoo: sudo emerge net-misc/curl"
        echo "  ‚Ä¢ Void: sudo xbps-install curl"
        echo "  ‚Ä¢ NixOS: nix-env -iA nixpkgs.curl"
        echo "  ‚Ä¢ Clear Linux: sudo swupd bundle-add curl"
        exit 1
    fi
fi
echo "‚úÖ curl found."

# Check for Homebrew on macOS (for mkcert)
if [[ "$(uname -s)" == "Darwin" ]] && ! command -v brew &> /dev/null && [[ "$SKIP_MKCERT" == false ]]; then
    echo "‚ùå [ERROR] 'brew' (Homebrew) is not installed."
    echo "Please install it from https://brew.sh/ and try again."
    echo "Or use --skip-mkcert to skip certificate tools installation."
    exit 1
fi
echo "--------------------------"
echo ""

# Function to install mkcert with multiple methods
install_mkcert() {
    echo "Checking for mkcert..."
    OS="$(uname -s)"

    # If mkcert is already installed, just ensure CA is trusted
    if command -v mkcert &> /dev/null; then
        echo "‚úÖ mkcert is already installed."
        echo "Ensuring local CA is trusted..."
        mkcert -install
        return 0
    fi

    case "${OS}" in
        Linux*)
            echo "Detected Linux OS."
            
            # Detect Linux distribution
            if [ -f /etc/os-release ]; then
                . /etc/os-release
                DISTRO=$ID
            else
                DISTRO="unknown"
            fi
            
            echo "Distribution: $DISTRO"
            
            # Try different installation methods based on distribution
            case "$DISTRO" in
                ubuntu|debian)
                    echo "Installing mkcert using apt-get..."
                    if sudo apt-get update && sudo apt-get install -y libnss3-tools; then
                        install_mkcert_binary
                    else
                        echo "Failed to install dependencies with apt-get"
                        return 1
                    fi
                    ;;
                fedora)
                    echo "Installing mkcert using dnf..."
                    if command -v dnf &> /dev/null && sudo dnf install -y nss-tools; then
                        if ! sudo dnf install -y mkcert 2>/dev/null; then
                            echo "mkcert not available in dnf, trying binary installation..."
                            install_mkcert_binary
                        fi
                    else
                        echo "Failed to install dependencies with dnf"
                        return 1
                    fi
                    ;;
                centos|rhel|rocky|almalinux)
                    echo "Installing mkcert on RHEL/CentOS-based system..."
                    
                    # Install NSS tools first
                    if command -v dnf &> /dev/null; then
                        sudo dnf install -y nss-tools
                    elif command -v yum &> /dev/null; then
                        sudo yum install -y nss-tools
                    fi
                    
                    # Try EPEL repository first
                    if ! install_mkcert_epel; then
                        echo "EPEL installation failed, trying binary installation..."
                        install_mkcert_binary
                    fi
                    ;;
                opensuse*|sles)
                    echo "Installing mkcert on openSUSE/SLES..."
                    if sudo zypper install -y mozilla-nss-tools; then
                        install_mkcert_binary
                    else
                        echo "Failed to install dependencies with zypper"
                        return 1
                    fi
                    ;;
                arch|manjaro)
                    echo "Installing mkcert using pacman..."
                    if sudo pacman -S --noconfirm nss; then
                        if ! sudo pacman -S --noconfirm mkcert 2>/dev/null; then
                            echo "mkcert not available in pacman, trying AUR or binary..."
                            install_mkcert_binary
                        fi
                    else
                        echo "Failed to install dependencies with pacman"
                        return 1
                    fi
                    ;;
                alpine)
                    echo "Installing mkcert on Alpine Linux..."
                    if sudo apk update && sudo apk add nss-tools; then
                        install_mkcert_binary
                    else
                        echo "Failed to install dependencies with apk"
                        return 1
                    fi
                    ;;
                void)
                    echo "Installing mkcert on Void Linux..."
                    if sudo xbps-install -y nss; then
                        install_mkcert_binary
                    else
                        echo "Failed to install dependencies with xbps"
                        return 1
                    fi
                    ;;
                gentoo)
                    echo "Installing mkcert on Gentoo..."
                    if sudo emerge --ask=n dev-libs/nss; then
                        install_mkcert_binary
                    else
                        echo "Failed to install dependencies with emerge"
                        return 1
                    fi
                    ;;
                nixos)
                    echo "Installing mkcert on NixOS..."
                    echo "‚ö†Ô∏è  Please add nss and mkcert to your system configuration:"
                    echo "1. Add to /etc/nixos/configuration.nix:"
                    echo "   environment.systemPackages = with pkgs; [ nss mkcert ];"
                    echo "2. Run: sudo nixos-rebuild switch"
                    echo "3. Re-run this script with --skip-mkcert if you prefer manual certs"
                    return 1
                    ;;
                clear-linux-os)
                    echo "Installing mkcert on Clear Linux..."
                    if sudo swupd bundle-add network-basic; then
                        install_mkcert_binary
                    else
                        echo "Failed to install dependencies with swupd"
                        return 1
                    fi
                    ;;
                *)
                    echo "Unknown or unsupported Linux distribution: $DISTRO"
                    echo "Attempting generic binary installation..."
                    install_mkcert_binary
                    ;;
            esac
            ;;
        Darwin*)
            echo "Detected macOS."
            echo "Installing mkcert with Homebrew..."
            if ! brew install mkcert; then
                echo "Failed to install mkcert with Homebrew"
                return 1
            fi
            ;;
        *)
            echo "Unsupported OS: ${OS}"
            echo "Attempting generic binary installation..."
            install_mkcert_binary
            ;;
    esac
    
    # Verify installation and trust CA
    if command -v mkcert &> /dev/null; then
        echo "‚úÖ mkcert installed successfully. Ensuring local CA is trusted..."
        mkcert -install
        return 0
    else
        echo "‚ùå [ERROR] mkcert installation failed."
        return 1
    fi
}

# Function to install mkcert from EPEL repository
install_mkcert_epel() {
    echo "Attempting to install mkcert from EPEL repository..."
    
    # Enable EPEL repository
    if command -v dnf &> /dev/null; then
        if ! sudo dnf install -y epel-release 2>/dev/null; then
            echo "Failed to install EPEL repository"
            return 1
        fi
        if sudo dnf install -y mkcert 2>/dev/null; then
            echo "‚úÖ mkcert installed from EPEL"
            return 0
        fi
    elif command -v yum &> /dev/null; then
        if ! sudo yum install -y epel-release 2>/dev/null; then
            echo "Failed to install EPEL repository"
            return 1
        fi
        if sudo yum install -y mkcert 2>/dev/null; then
            echo "‚úÖ mkcert installed from EPEL"
            return 0
        fi
    fi
    
    return 1
}

# Function to install mkcert binary directly from GitHub releases
install_mkcert_binary() {
    echo "Installing mkcert from GitHub releases..."
    
    # Detect architecture
    ARCH="$(uname -m)"
    case "$ARCH" in
        x86_64) ARCH="amd64" ;;
        aarch64|arm64) ARCH="arm64" ;;
        armv7l) ARCH="arm" ;;
        i386|i686) ARCH="386" ;;
        *) 
            echo "Unsupported architecture: $ARCH"
            return 1
            ;;
    esac
    
    # Detect OS for binary naming
    OS_LOWER="$(uname -s | tr '[:upper:]' '[:lower:]')"
    
    # Get latest release version
    echo "Fetching latest mkcert release information..."
    LATEST_VERSION=$(curl -s https://api.github.com/repos/FiloSottile/mkcert/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    
    if [ -z "$LATEST_VERSION" ]; then
        echo "Failed to get latest version information"
        return 1
    fi
    
    echo "Latest version: $LATEST_VERSION"
    
    # Construct download URL
    BINARY_NAME="mkcert-${LATEST_VERSION}-${OS_LOWER}-${ARCH}"
    DOWNLOAD_URL="https://github.com/FiloSottile/mkcert/releases/download/${LATEST_VERSION}/${BINARY_NAME}"
    
    echo "Downloading: $DOWNLOAD_URL"
    
    # Download and install
    if curl -L -o /tmp/mkcert "$DOWNLOAD_URL"; then
        sudo chmod +x /tmp/mkcert
        sudo mv /tmp/mkcert /usr/local/bin/mkcert
        echo "‚úÖ mkcert binary installed to /usr/local/bin/mkcert"
        return 0
    else
        echo "Failed to download mkcert binary"
        return 1
    fi
}

# --- Main script ---

# 1. Install mkcert (unless skipped)
if [[ "$SKIP_MKCERT" == true ]]; then
    echo "‚è≠Ô∏è  Skipping mkcert installation as requested."
    echo "   Note: You'll need to provide your own SSL certificates or use 'none' strategy."
else
    if ! install_mkcert; then
        echo ""
        echo "‚ö†Ô∏è  [WARNING] Failed to install mkcert automatically."
        echo ""
        echo "üìã You can still use easy-opal with these options:"
        echo "1. Use 'none' strategy (default) - No SSL, for local development or reverse proxy"
        echo "2. Use 'manual' strategy - Provide your own certificates"
        echo "3. Use 'letsencrypt' strategy - For public domains"
        echo ""
        echo "If you want self-signed certificates, you can install mkcert manually:"
        echo "  ‚Ä¢ Download from: https://github.com/FiloSottile/mkcert/releases"
        echo "  ‚Ä¢ Or use your package manager"
        echo ""
        echo "Continuing setup without mkcert..."
        SKIP_MKCERT=true
    fi
fi

# 2. Install uv and dependencies
echo -e "\n--- Setting up Python Environment with uv ---"

# Function to verify uv installation and add to PATH
verify_uv_installation() {
    # Add common uv paths to PATH for this session
    export PATH="$HOME/.local/bin:$HOME/.cargo/bin:/usr/local/bin:$PATH"

    if command -v uv &> /dev/null; then
        return 0
    fi

    # Check common installation locations manually
    for uv_path in "$HOME/.local/bin/uv" "$HOME/.cargo/bin/uv" "/usr/local/bin/uv" "/opt/homebrew/bin/uv"; do
        if [ -x "$uv_path" ]; then
            export PATH="$(dirname "$uv_path"):$PATH"
            return 0
        fi
    done

    return 1
}

# Function to install uv via official installer (primary method)
install_uv_official() {
    echo "üì¶ Installing uv via official installer..."
    if curl -LsSf https://astral.sh/uv/install.sh | sh; then
        if verify_uv_installation; then
            echo "‚úÖ uv installed successfully via official installer"
            return 0
        fi
    fi
    return 1
}

# Function to install uv via pip (fallback method)
install_uv_pip() {
    echo "üì¶ Installing uv via pip..."
    if python3 -m pip install --user uv 2>/dev/null || pip3 install --user uv 2>/dev/null; then
        if verify_uv_installation; then
            echo "‚úÖ uv installed successfully via pip"
            return 0
        fi
    fi
    return 1
}

# Function to install uv via pipx (alternative method)
install_uv_pipx() {
    if command -v pipx &> /dev/null; then
        echo "üì¶ Installing uv via pipx..."
        if pipx install uv 2>/dev/null; then
            if verify_uv_installation; then
                echo "‚úÖ uv installed successfully via pipx"
                return 0
            fi
        fi
    fi
    return 1
}

# Function to install uv via system package manager
install_uv_package_manager() {
    echo "üì¶ Attempting to install uv via system package manager..."
    OS="$(uname -s)"

    if [ "$OS" = "Darwin" ]; then
        # macOS - try Homebrew
        if command -v brew &> /dev/null; then
            echo "Installing uv with Homebrew..."
            if brew install uv 2>/dev/null; then
                if verify_uv_installation; then
                    echo "‚úÖ uv installed successfully via Homebrew"
                    return 0
                fi
            fi
        fi
    elif [ "$OS" = "Linux" ]; then
        # Linux - try various package managers
        if [ -f /etc/os-release ]; then
            . /etc/os-release
            DISTRO=$ID
        else
            DISTRO="unknown"
        fi

        case "$DISTRO" in
            arch|manjaro)
                if command -v pacman &> /dev/null; then
                    echo "Installing uv with pacman..."
                    if sudo pacman -S --noconfirm uv 2>/dev/null; then
                        if verify_uv_installation; then
                            echo "‚úÖ uv installed successfully via pacman"
                            return 0
                        fi
                    fi
                fi
                ;;
            alpine)
                if command -v apk &> /dev/null; then
                    echo "Installing uv with apk..."
                    if sudo apk add py3-uv uv 2>/dev/null; then
                        if verify_uv_installation; then
                            echo "‚úÖ uv installed successfully via apk"
                            return 0
                        fi
                    fi
                fi
                ;;
            fedora)
                if command -v dnf &> /dev/null; then
                    echo "Installing uv with dnf..."
                    if sudo dnf install -y uv 2>/dev/null; then
                        if verify_uv_installation; then
                            echo "‚úÖ uv installed successfully via dnf"
                            return 0
                        fi
                    fi
                fi
                ;;
            opensuse*|sles)
                if command -v zypper &> /dev/null; then
                    echo "Installing uv with zypper..."
                    if sudo zypper install -y uv 2>/dev/null; then
                        if verify_uv_installation; then
                            echo "‚úÖ uv installed successfully via zypper"
                            return 0
                        fi
                    fi
                fi
                ;;
            void)
                if command -v xbps-install &> /dev/null; then
                    echo "Installing uv with xbps..."
                    if sudo xbps-install -y uv 2>/dev/null; then
                        if verify_uv_installation; then
                            echo "‚úÖ uv installed successfully via xbps"
                            return 0
                        fi
                    fi
                fi
                ;;
            gentoo)
                if command -v emerge &> /dev/null; then
                    echo "Installing uv with emerge..."
                    if sudo emerge --ask=n dev-python/uv 2>/dev/null; then
                        if verify_uv_installation; then
                            echo "‚úÖ uv installed successfully via emerge"
                            return 0
                        fi
                    fi
                fi
                ;;
            nixos)
                echo "‚ö†Ô∏è  NixOS detected. Please add uv to your system configuration:"
                echo "   environment.systemPackages = with pkgs; [ uv ];"
                echo "   Then run: sudo nixos-rebuild switch"
                return 1
                ;;
        esac

        # Try Homebrew on Linux if available (Linuxbrew)
        if command -v brew &> /dev/null; then
            echo "Installing uv with Homebrew (Linux)..."
            if brew install uv 2>/dev/null; then
                if verify_uv_installation; then
                    echo "‚úÖ uv installed successfully via Homebrew"
                    return 0
                fi
            fi
        fi
    fi

    return 1
}

# Function to download uv binary directly (last resort fallback)
install_uv_binary() {
    echo "üì¶ Installing uv binary directly from GitHub..."

    # Detect architecture
    ARCH="$(uname -m)"
    case "$ARCH" in
        x86_64) ARCH="x86_64" ;;
        aarch64|arm64) ARCH="aarch64" ;;
        armv7l) ARCH="armv7" ;;
        i686|i386) ARCH="i686" ;;
        *)
            echo "‚ö†Ô∏è  Unsupported architecture: $ARCH"
            return 1
            ;;
    esac

    # Detect OS and libc type
    OS="$(uname -s)"
    case "$OS" in
        Linux)
            # Check if musl or glibc
            if ldd --version 2>&1 | grep -qi musl || [ -f /etc/alpine-release ]; then
                OS_NAME="unknown-linux-musl"
            else
                OS_NAME="unknown-linux-gnu"
            fi
            ;;
        Darwin)
            OS_NAME="apple-darwin"
            ;;
        FreeBSD)
            OS_NAME="unknown-freebsd"
            ;;
        *)
            echo "‚ö†Ô∏è  Unsupported OS: $OS"
            return 1
            ;;
    esac

    # Get latest release version
    echo "Fetching latest uv release..."
    LATEST_VERSION=$(curl -s https://api.github.com/repos/astral-sh/uv/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')

    if [ -z "$LATEST_VERSION" ]; then
        # Fallback to a known stable version
        LATEST_VERSION="0.5.0"
        echo "Could not fetch latest version, using fallback: $LATEST_VERSION"
    fi

    echo "Version: $LATEST_VERSION"

    # Construct download URL
    BINARY_NAME="uv-${ARCH}-${OS_NAME}.tar.gz"
    DOWNLOAD_URL="https://github.com/astral-sh/uv/releases/download/${LATEST_VERSION}/${BINARY_NAME}"

    echo "Downloading: $DOWNLOAD_URL"

    # Download and install
    TEMP_DIR=$(mktemp -d)
    if curl -fSL -o "$TEMP_DIR/uv.tar.gz" "$DOWNLOAD_URL" 2>/dev/null; then
        tar -xzf "$TEMP_DIR/uv.tar.gz" -C "$TEMP_DIR" 2>/dev/null

        # Find the uv binary in extracted files
        UV_BINARY=$(find "$TEMP_DIR" -name "uv" -type f 2>/dev/null | head -1)

        if [ -n "$UV_BINARY" ]; then
            chmod +x "$UV_BINARY"
            mkdir -p "$HOME/.local/bin"
            mv "$UV_BINARY" "$HOME/.local/bin/uv"

            # Also copy uvx if available
            UVX_BINARY=$(find "$TEMP_DIR" -name "uvx" -type f 2>/dev/null | head -1)
            if [ -n "$UVX_BINARY" ]; then
                chmod +x "$UVX_BINARY"
                mv "$UVX_BINARY" "$HOME/.local/bin/uvx"
            fi

            export PATH="$HOME/.local/bin:$PATH"
            rm -rf "$TEMP_DIR"

            if verify_uv_installation; then
                echo "‚úÖ uv binary installed successfully to ~/.local/bin"
                return 0
            fi
        fi
    else
        echo "Download failed. Trying alternative URL format..."
        # Try alternative binary naming convention
        BINARY_NAME="uv-${ARCH}-${OS_NAME}"
        DOWNLOAD_URL="https://github.com/astral-sh/uv/releases/download/${LATEST_VERSION}/${BINARY_NAME}"

        if curl -fSL -o "$TEMP_DIR/uv" "$DOWNLOAD_URL" 2>/dev/null; then
            chmod +x "$TEMP_DIR/uv"
            mkdir -p "$HOME/.local/bin"
            mv "$TEMP_DIR/uv" "$HOME/.local/bin/uv"
            export PATH="$HOME/.local/bin:$PATH"
            rm -rf "$TEMP_DIR"

            if verify_uv_installation; then
                echo "‚úÖ uv binary installed successfully to ~/.local/bin"
                return 0
            fi
        fi
    fi

    rm -rf "$TEMP_DIR"
    return 1
}

# Main uv installation function with multiple fallback methods
install_uv() {
    local attempt=1
    local max_attempts=2

    while [ $attempt -le $max_attempts ]; do
        echo "üîÑ Installation attempt $attempt/$max_attempts..."

        # Try methods in order of preference
        # 1. Official installer (most reliable, handles all platforms)
        if install_uv_official; then
            return 0
        fi
        echo "‚ö†Ô∏è  Official installer failed, trying alternatives..."

        # 2. System package manager (if available)
        if install_uv_package_manager; then
            return 0
        fi

        # 3. pip installation (widely available)
        if install_uv_pip; then
            return 0
        fi

        # 4. pipx installation (if available)
        if install_uv_pipx; then
            return 0
        fi

        # 5. Direct binary download (last resort)
        if install_uv_binary; then
            return 0
        fi

        if [ $attempt -lt $max_attempts ]; then
            echo "üîÑ All methods failed. Retrying in 3 seconds..."
            sleep 3
        fi

        attempt=$((attempt + 1))
    done

    return 1
}

# Check if uv is already installed
if verify_uv_installation; then
    echo "‚úÖ uv is already installed"
    uv_version=$(uv --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    if [ -n "$uv_version" ]; then
        echo "üì¶ uv version: $uv_version"
    fi
else
    echo "uv not found. Installing uv..."

    if ! install_uv; then
        echo ""
        echo "‚ùå [ERROR] Failed to install uv after multiple attempts"
        echo ""
        echo "üìã Manual installation options:"
        echo ""
        echo "1. Official installer (recommended):"
        echo "   curl -LsSf https://astral.sh/uv/install.sh | sh"
        echo ""
        echo "2. Via pip:"
        echo "   pip3 install uv"
        echo ""
        echo "3. Via Homebrew (macOS/Linux):"
        echo "   brew install uv"
        echo ""
        echo "4. Via pacman (Arch Linux):"
        echo "   sudo pacman -S uv"
        echo ""
        echo "5. Download binary directly:"
        echo "   https://github.com/astral-sh/uv/releases"
        echo ""
        echo "After installing uv, re-run: ./setup"
        echo ""
        exit 1
    fi
fi

echo "‚úÖ uv is available."

# Use uv to ensure Python is available (uv can auto-download Python if needed)
echo ""
echo "--- Ensuring Python availability via uv ---"

ensure_python_with_uv() {
    # uv can automatically download and manage Python versions
    # First, check if a suitable Python is already available
    if uv python find ">=3.8" &>/dev/null; then
        PYTHON_PATH=$(uv python find ">=3.8" 2>/dev/null)
        echo "‚úÖ Found suitable Python: $PYTHON_PATH"
        return 0
    fi

    # If not, let uv install Python
    echo "üì¶ No suitable Python found. Using uv to install Python 3.11..."
    if uv python install 3.11 2>&1; then
        echo "‚úÖ Python 3.11 installed via uv"

        # Verify it was installed correctly
        if uv python find ">=3.8" &>/dev/null; then
            PYTHON_PATH=$(uv python find ">=3.8" 2>/dev/null)
            echo "‚úÖ Verified Python installation: $PYTHON_PATH"
            return 0
        fi
    fi

    echo "‚ö†Ô∏è  uv could not install Python automatically"
    return 1
}

if ! ensure_python_with_uv; then
    echo ""
    echo "‚ö†Ô∏è  Could not ensure Python via uv. Checking system Python..."

    # Check if system Python is at least usable
    if python3 -c "import sys; exit(0 if sys.version_info >= (3, 8) else 1)" 2>/dev/null; then
        echo "‚úÖ System Python 3.8+ is available as fallback"
    else
        echo ""
        echo "‚ùå [ERROR] No suitable Python 3.8+ found"
        echo ""
        echo "uv could not automatically install Python, and no compatible"
        echo "system Python was found."
        echo ""
        echo "üìã Options to resolve this:"
        echo ""
        echo "1. Run with --upgrade-python flag:"
        echo "   ./setup --upgrade-python"
        echo ""
        echo "2. Install Python manually:"
        echo "   ‚Ä¢ Ubuntu/Debian: sudo apt install python3.11"
        echo "   ‚Ä¢ CentOS/RHEL:   sudo dnf install python3.11"
        echo "   ‚Ä¢ macOS:         brew install python@3.11"
        echo "   ‚Ä¢ Or download from: https://www.python.org/downloads/"
        echo ""
        echo "3. Use pyenv to manage Python versions:"
        echo "   curl https://pyenv.run | bash"
        echo "   pyenv install 3.11"
        echo "   pyenv global 3.11"
        echo ""
        exit 1
    fi
fi

# If we needed to upgrade Python and uv handled it, verify one more time
if [ "$PYTHON_NEEDS_UPGRADE" = true ]; then
    echo "üîç Final Python verification..."
    if uv python find ">=3.8" &>/dev/null; then
        echo "‚úÖ Python requirement satisfied via uv"
    elif python3 -c "import sys; exit(0 if sys.version_info >= (3, 8) else 1)" 2>/dev/null; then
        echo "‚úÖ Python requirement satisfied via system Python"
    else
        echo "‚ùå [ERROR] Python 3.8+ is still not available"
        echo "Please install Python 3.8 or higher manually and re-run ./setup"
        exit 1
    fi
fi

# Install project dependencies with better error handling
echo "Installing project dependencies with uv... (This may take a moment)"

# Function to verify the virtual environment is correctly set up
verify_venv() {
    if [ ! -d ".venv" ]; then
        return 1
    fi

    # Check for Python executable in venv
    if [ -x ".venv/bin/python" ] || [ -x ".venv/Scripts/python.exe" ]; then
        return 0
    fi

    return 1
}

# Function to install dependencies using uv sync (preferred method)
install_deps_uv_sync() {
    echo "üì¶ Installing dependencies with 'uv sync'..."
    (
        unset VIRTUAL_ENV
        # Use --python-preference managed to let uv handle Python if needed
        # Use --frozen if lockfile exists to ensure reproducibility
        if [ -f "uv.lock" ]; then
            uv sync --frozen 2>&1
        else
            uv sync 2>&1
        fi
    )
    return $?
}

# Function to install dependencies using uv with explicit Python (alternative method)
install_deps_uv_python() {
    echo "üì¶ Installing dependencies with 'uv sync' and managed Python..."
    (
        unset VIRTUAL_ENV
        # Let uv find or install a suitable Python version
        uv sync --python ">=3.8" 2>&1
    )
    return $?
}

# Function to install dependencies using uv pip (fallback method)
install_deps_uv_pip() {
    echo "üì¶ Installing dependencies with 'uv pip' (fallback)..."
    (
        unset VIRTUAL_ENV

        # Create venv if it doesn't exist
        if [ ! -d ".venv" ]; then
            echo "Creating virtual environment..."
            # Try uv venv first, then fall back to python3 -m venv
            if ! uv venv .venv 2>&1; then
                echo "uv venv failed, trying python3 -m venv..."
                python3 -m venv .venv 2>&1 || return 1
            fi
        fi

        # Install the project in editable mode using uv pip
        echo "Installing project with uv pip..."
        if uv pip install -e . --python .venv/bin/python 2>&1; then
            return 0
        fi

        # Fallback to regular pip
        echo "uv pip failed, trying regular pip..."
        if [ -x ".venv/bin/pip" ]; then
            .venv/bin/pip install -e . 2>&1
        elif [ -x ".venv/bin/python" ]; then
            .venv/bin/python -m pip install -e . 2>&1
        else
            return 1
        fi
    )
    return $?
}

# Function to install dependencies with retry logic and multiple methods
install_dependencies() {
    local attempt=1
    local max_attempts=3

    while [ $attempt -le $max_attempts ]; do
        echo "üîÑ Dependency installation attempt $attempt/$max_attempts..."

        # Clean up any corrupted state on retry
        if [ $attempt -gt 1 ]; then
            echo "üßπ Cleaning up previous attempt..."
            rm -rf .venv 2>/dev/null || true
            # Only remove lockfile on final attempt
            if [ $attempt -eq $max_attempts ]; then
                rm -f uv.lock 2>/dev/null || true
            fi
            sleep 1
        fi

        # Try uv sync first (preferred method - uses lockfile)
        if install_deps_uv_sync; then
            if verify_venv; then
                echo "‚úÖ Dependencies installed successfully with uv sync"
                return 0
            else
                echo "‚ö†Ô∏è  uv sync completed but venv verification failed"
            fi
        else
            echo "‚ö†Ô∏è  uv sync failed"
        fi

        # On second attempt, try with explicit Python management
        if [ $attempt -eq 2 ]; then
            echo "üîÑ Trying with uv-managed Python..."
            if install_deps_uv_python; then
                if verify_venv; then
                    echo "‚úÖ Dependencies installed successfully with managed Python"
                    return 0
                fi
            fi
        fi

        # Fallback to uv pip / manual venv creation
        if [ $attempt -ge 2 ]; then
            echo "üîÑ Trying fallback installation method..."
            if install_deps_uv_pip; then
                if verify_venv; then
                    echo "‚úÖ Dependencies installed successfully with fallback method"
                    return 0
                fi
            fi
        fi

        if [ $attempt -lt $max_attempts ]; then
            echo "üîÑ Retrying in 2 seconds..."
            sleep 2
        fi

        attempt=$((attempt + 1))
    done

    return 1
}

if ! install_dependencies; then
    echo ""
    echo "‚ùå [ERROR] Failed to install project dependencies"
    echo ""
    echo "üìã Troubleshooting steps:"
    echo ""
    echo "1. Python version incompatibility (requires Python 3.8+)"
    echo "   Check: python3 --version"
    echo "   Fix: ./setup --upgrade-python"
    echo ""
    echo "2. Network connectivity issues"
    echo "   Check: curl -I https://pypi.org"
    echo "   Fix: Check internet connection and firewall settings"
    echo ""
    echo "3. Corrupted virtual environment"
    echo "   Fix: rm -rf .venv && ./setup"
    echo ""
    echo "4. Corrupted lockfile"
    echo "   Fix: rm -f uv.lock && ./setup"
    echo ""
    echo "5. Missing system build tools"
    echo "   Ubuntu/Debian: sudo apt install build-essential python3-dev"
    echo "   CentOS/RHEL: sudo dnf groupinstall 'Development Tools'"
    echo "   macOS: xcode-select --install"
    echo ""
    echo "üí° Manual installation commands:"
    echo "   uv sync                    # Preferred method"
    echo "   uv venv && uv pip install -e .  # Alternative method"
    echo ""
    exit 1
fi

# Verify the installation worked correctly
if ! verify_venv; then
    echo ""
    echo "‚ùå [ERROR] Virtual environment verification failed"
    echo "The .venv directory exists but appears to be corrupted."
    echo ""
    echo "Fix: rm -rf .venv && ./setup"
    echo ""
    exit 1
fi

# Make the wrapper script executable
chmod +x easy-opal

# Final verification: test that easy-opal actually works
echo ""
echo "--- Final Verification ---"
if ./.venv/bin/python -m src.cli --help &>/dev/null; then
    echo "‚úÖ easy-opal CLI verified and working"
else
    echo "‚ö†Ô∏è  Warning: easy-opal CLI verification failed"
    echo "   The installation may have issues. Try running:"
    echo "   ./easy-opal --help"
    echo ""
fi

echo -e "\n‚úÖ Setup complete! The environment is ready."

if [[ "$SKIP_MKCERT" == true ]]; then
    echo ""
    echo "‚ö†Ô∏è  IMPORTANT: mkcert was skipped during setup."
    echo "   When running './easy-opal setup', choose one of these SSL strategies:"
    echo "   ‚Ä¢ 'none' (default) - No SSL, for local development or reverse proxy"
    echo "   ‚Ä¢ 'manual' - Provide your own certificate files"
    echo "   ‚Ä¢ 'letsencrypt' - Use Let's Encrypt (requires public domain)"
    echo ""
fi

echo "You can now run the tool using the './easy-opal' wrapper script."
echo "For example, to start the setup wizard, run:"

# ANSI escape codes
BOLD_YELLOW='\033[1;33m'
NC='\033[0m'
echo -e "${BOLD_YELLOW}./easy-opal setup${NC}" 